const Discord = require('discord.js');
const client = new Discord.Client();
const fs = require("fs"); 
const prefix = 'S!'

client.on('ready', () => {
  console.log(`Logged in as ${client.user.tag}!`);
client.user.setGame(`Nothing..`,"http://twitch.tv/S-F")
  console.log('')
  console.log('')
  console.log('‚ïî[‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê]‚ïó')
  console.log(`[Start] ${new Date()}`);
  console.log('‚ïö[‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê]‚ïù')
  console.log('')
  console.log('‚ïî[‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê]‚ïó');
  console.log(`Logged in as * [ " ${client.user.username} " ]`);
  console.log('')
  console.log('Informations :')
  console.log('')
  console.log(`servers! [ " ${client.guilds.size} " ]`);
  console.log(`Users! [ " ${client.users.size} " ]`);
  console.log(`channels! [ " ${client.channels.size} " ]`);
  console.log('‚ïö[‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê]‚ïù')
  console.log('')
  console.log('‚ïî[‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê]‚ïó')
  console.log(' Bot Is Online')
  console.log('‚ïö[‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê]‚ïù')
  console.log('')
  console.log('')
});




const credits = JSON.parse(fs.readFileSync("./creditsCode.json", "utf8"));
const coolDown = new Set();
 
client.on('message',async message => {
   
if(message.author.bot) return;
if(!credits[message.author.id]) credits[message.author.id] = {
    credits: 50
};
 
let userData = credits[message.author.id];
let m = userData.credits;
 
fs.writeFile("./creditsCode.json", JSON.stringify(credits), (err) => {
    if (err) console.error(err);
  });
  credits[message.author.id] = {
      credits: m + 0.5,
  }
 
    if(message.content.startsWith(prefix + "credit" || prefix + "credits")) {
message.channel.send(`**${message.author.username}, your :credit_card: balance is \`\`${userData.credits}\`\`.**`);
}
});
 
client.on('message', async message => {
    let amount = 250;
    if(message.content.startsWith(prefix + "daily")) {
    if(message.author.bot) return;
    if(coolDown.has(message.author.id)) return message.channel.send(`**:stopwatch: | ${message.author.username}, your daily :yen: credits refreshes in \`\`1 Day\`\`.**`);
   
    let userData = credits[message.author.id];
    let m = userData.credits + amount;
    credits[message.author.id] = {
    credits: m
    };
 
    fs.writeFile("./creditsCode.json", JSON.stringify(userData.credits + amount), (err) => {
    if (err) console.error(err);
    });
   
    message.channel.send(`**:atm: | ${message.author.username}, you received your :yen: ${amount} credits!**`).then(() => {
        coolDown.add(message.author.id);
    });
   
    setTimeout(() => {
       coolDown.remove(message.author.id);
    },86400000);
    }
});





client.on("message", (message) => {
            if (message.channel.type === "dm") {
        if (message.author.id === client.user.id) return;
        let yumz = new Discord.RichEmbed()
                    .setTimestamp()
                    .setTitle("Direct Message To The Bot")
                    .addField(`Sent By:`, `<@${message.author.id}>`)
                    .setColor("RANDOM")
                    .setThumbnail(message.author.displayAvatarURL)
                    .addField(`Message: `, `\n\n\`\`\`${message.content}\`\`\``)
                    .setFooter(`DM Bot Messages | DM Logs`)
                client.users.get("459806154961453066").send(yumz)
            }
});





client.on('guildCreate', guild => {
    
  client.channels.get("495536963554902027")
const embed = new Discord.RichEmbed()
   .setAuthor(`ÿ®Ÿàÿ™ŸÉ ÿØÿÆŸÑ ÿ≥Ÿäÿ±ŸÅÿ± ÿ¨ÿØŸäÿØ ŸÖÿ®ÿ±ŸàŸÉ ‚úÖ`)
   .setDescription(`**
Server name: __${guild.name}__
Server id: __${guild.id}__
Server owner: __${guild.owner}__
Member Count: __${guild.memberCount}__
Servers Counter : __${client.guilds.size}__**`)
         .setColor("#f3ae10")
         .addField("New Server!")
         .setFooter('Slash Bot' , client.user.avatarURL)
           client.channels.get("495536963554902027").send({embed});
}

);




client.on('guildDelete', guild => {
  client.channels.get("495536963554902027")
const embed = new Discord.RichEmbed()
   .setAuthor(`Slash Bot Bot left a server ‚ùé`)
   .setDescription(`**
Server name: __${guild.name}__
Server id: __${guild.id}__
Server owner: __${guild.owner}__
Members Count: __${guild.memberCount}__
Servers Counter : __${client.guilds.size}__**`)
         .setColor("#f3ae10")
         .setFooter('Slash Bot' , client.user.avatarURL)
           client.channels.get("495536963554902027").send({embed});
}

);









client.on('message' , najzx => {
    var prefix = "S!";
    let user = najzx.mentions.users.first()|| client.users.get(najzx.content.split(' ')[1])
    if(najzx.content.startsWith(prefix + 'unban')) {
        if(!najzx.member.hasPermission('ADMINISTRATOR')) return najzx.channel.send('‚ùå|**\`ADMINISTRATOR\`ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÑÿØŸäŸÉ ÿ±ÿ™ÿ®ÿ©`**');
        if(!user) return  najzx.channel.send(`Do this ${prefix} <@ID user> \n or \n ${prefix}unban ID user`);
        najzx.guild.unban(user);
        najzx.guild.owner.send(`ŸÑŸÇÿØ ÿ™ŸÖ ŸÅŸÉ ÿßŸÑÿ®ÿßŸÜÿØ ÿπŸÜ ÿßŸÑÿ¥ÿÆÿµ \n ${user} \n By : <@${najzx.author.id}>`)
        var embed = new Discord.RichEmbed()
        .setThumbnail(najzx.author.avatarURl)
        .setColor("RANDOM")
        .setTitle('**Unban** !')
        .addField('**User Unban :** ', `${user}` , true)
        .addField('**By :**' ,       ` <@${najzx.author.id}> ` , true)
        .setAuthor(najzx.guild.name)
       .setFooter('Requested by '+najzx.author.username, najzx.author.avatarURL)
        najzx.channel.sendEmbed(embed)
    }
  });




client.on('message', async message =>{
  var prefix = "S!";
const ms = require("ms");
if (message.author.omar) return;
if (!message.content.startsWith(prefix)) return;
if(!message.channel.guild) return message.channel.send('').then(m => m.delete(5000));
if(!message.guild.member(client.user).hasPermission("MANAGE_ROLES")) return message.reply("**I Don't Have `MANAGE_ROLES` Permission**").then(msg => msg.delete(6000))
var command = message.content.split(" ")[0];
command = command.slice(prefix.length);
var args = message.content.split(" ").slice(1);
    if(command == "mute") {
    let tomute = message.guild.member(message.mentions.users.first() || message.guild.members.get(args[0]));
    if(!tomute) return message.reply("**Ÿäÿ¨ÿ® ÿπŸÑŸäŸÉ ÿßŸÑŸÖŸÜÿ¥ŸÜ ÿßŸàŸÑÿßŸë**:x: ") .then(m => m.delete(5000));
    if(tomute.hasPermission("MANAGE_MESSAGES"))return      message.channel.send('**ŸÑŸÑÿ£ÿ≥ŸÅ ŸÑÿß ÿ£ŸÖÿ™ŸÑŸÉ ÿµŸÑÿßÿ≠Ÿäÿ©** `MANAGE_MASSAGEES`');
    let muterole = message.guild.roles.find(`name`, "Muted");
    //start of create role
    if(!muterole){
      try{
        muterole = await message.guild.createRole({
          name: "Muted",
          color: "#070000",
          permissions:[]
        })
        message.guild.channels.forEach(async (channel, id) => {
          await channel.overwritePermissions(muterole, {
            SEND_MESSAGES: false,
            ADD_REACTIONS: false,
            SPEAK : false
          });
        });
      }catch(e){
        console.log(e.stack);
      }
    }
    //end of create role
    let mutetime = args[1];
    if(!mutetime) return message.reply("**Ÿäÿ±ÿ¨Ÿâ ÿ™ÿ≠ÿØŸäÿØ ŸàŸÇÿ™ ÿßŸÑŸÖŸäŸàÿ™**:x:");
 
    await(tomute.addRole(muterole.id));
message.reply(`<@${tomute.id}> **ÿ™ŸÖ ÿßÿπÿ∑ÿßÿ¶Ÿá ŸÖŸäŸàÿ™ ŸàŸÖÿØÿ© ÿßŸÑŸÖŸäŸàÿ™** : ${ms(ms(mutetime))}`);
setTimeout(function(){
      tomute.removeRole(muterole.id);
      message.channel.send(`<@${tomute.id}> **ÿßŸÜŸÇÿ∂Ÿâ ÿßŸÑŸàŸÇÿ™ Ÿàÿ™ŸÖ ŸÅŸÉ ÿßŸÑŸÖŸäŸàÿ™ ÿπŸÜ ÿßŸÑÿ¥ÿÆÿµ**:white_check_mark: `);
    }, ms(mutetime));
 
 
 
  }
if(command === `unmute`) {
  if(!message.member.hasPermission("MANAGE_ROLES")) return message.channel.sendMessage("**ŸÑŸäÿ≥ ŸÑÿØŸäŸÉ ÿµŸÑÿßÿ≠Ÿäÿ© ŸÑŸÅŸÉ ÿπŸÜ ÿßŸÑÿ¥ÿÆÿµ ŸÖŸäŸàÿ™**:x: ").then(m => m.delete(5000));
if(!message.guild.member(client.user).hasPermission("MANAGE_ROLES")) return message.reply("**I Don't Have `MANAGE_ROLES` Permission**").then(msg => msg.delete(6000))
 
  let toMute = message.guild.member(message.mentions.users.first()) || message.guild.members.get(args[0]);
  if(!toMute) return message.channel.sendMessage("**ÿπŸÑŸäŸÉ ÿßŸÑŸÖŸÜÿ¥ŸÜ ÿ£ŸàŸÑÿßŸë**:x: ");
 
  let role = message.guild.roles.find (r => r.name === "Muted");
 
  if(!role || !toMute.roles.has(role.id)) return message.channel.sendMessage("**ŸÑŸÖ Ÿäÿ™ŸÖ ÿßÿπÿ∑ÿßÿ° Ÿáÿ∞Ÿá ÿ¥ÿÆÿµ ŸÖŸäŸàÿ™ ŸÖŸÜ ÿßŸÑÿ£ÿ≥ÿßÿ≥**:x:")
 
  await toMute.removeRole(role)
  message.channel.sendMessage("**ŸÑŸÇÿØ ÿ™ŸÖ ŸÅŸÉ ÿßŸÑŸÖŸäŸàÿ™ ÿπŸÜ ÿ¥ÿÆÿµ ÿ®ŸÜÿ¨ÿßÿ≠**:white_check_mark:");
 
  return;
 
  }
 
});





client.on('message', message => {
    if (message.content.startsWith(prefix + 'clear')) {
      if (!message.member.hasPermission('MANAGE_MESSAGES')) return message.reply(`ŸÖÿßÿπŸÜÿØŸÉ Ÿáÿ∞ÿß ÿßŸÑÿ®ÿ±ŸÖÿ¥ŸÜ[*MANAGE_MESSAGES*] `).catch(console.error);
  message.delete()
  if(!message.channel.guild) return;
  let args = message.content.split(" ").slice(1);
  
  const messagecount = parseInt(args.join(' '));
  
  message.channel.fetchMessages({
  
  limit: messagecount
  
  }).then(messages => message.channel.bulkDelete(messages));
  message.channel.sendMessage("", {embed: {
    title: "``‚úèÔ∏è‚úÖ ÿ™ŸÄŸÄŸÖ ŸÖÿ≥ÿ≠ ÿßŸÑÿ¥ÿßÿ™ ``",
    color: 0x06DF00,
    footer: {
    
    }
    }}).then(msg => {msg.delete(3000)});
  };
  
  });




client.on('message', message => {
    if (message.content.startsWith("S!botinfo")) {
    message.channel.send({
        embed: new Discord.RichEmbed()
            .setAuthor(client.user.username,client.user.avatarURL)
            .setThumbnail(client.user.avatarURL)
            .setColor('RANDOM')
            .setTitle('``INFO Slash Bot`` ')
            .addField('``My Ping``' , [`${Date.now() - message.createdTimestamp}` + 'MS'], true)
            .addField('``RAM Usage``', `[${(process.memoryUsage().rss / 1048576).toFixed()}MB]`, true)
            .addField('``servers``', [client.guilds.size], true)
            .addField('``channels``' , `[ ${client.channels.size} ]` , true)
            .addField('``Users``' ,`[ ${client.users.size} ]` , true)
            .addField('``My Name``' , `[ ${client.user.tag} ]` , true)
            .addField('``My ID``' , `[ ${client.user.id} ]` , true)
                  .addField('``My Prefix``' , `[ S! ]` , true)
                  .addField('``My Language``' , `[ Java Script ]` , true)
                  .setFooter('By | A7med')
    })
}
});





client.on('message', message => {
    var prefix = "S!"
  if (message.author.x5bz) return;
  if (!message.content.startsWith(prefix)) return;

  let command = message.content.split(" ")[0];
  command = command.slice(prefix.length);

  let args = message.content.split(" ").slice(1);

  if (command == "ban") {
               if(!message.channel.guild) return message.reply('** This command only for servers**');
         
  if(!message.guild.member(message.author).hasPermission("BAN_MEMBERS")) return message.reply("**You Don't Have ` BAN_MEMBERS ` Permission**");
  if(!message.guild.member(client.user).hasPermission("BAN_MEMBERS")) return message.reply("**I Don't Have ` BAN_MEMBERS ` Permission**");
  let user = message.mentions.users.first();
  let reason = message.content.split(" ").slice(2).join(" ");
  /*let b5bzlog = client.channels.find("name", "5bz-log");
  if(!b5bzlog) return message.reply("I've detected that this server doesn't have a 5bz-log text channel.");*/
  if (message.mentions.users.size < 1) return message.reply("**ŸÖŸÜÿ¥ŸÜ ÿ¥ÿÆÿµ**");
  if(!reason) return message.reply ("**ÿßŸÉÿ™ÿ® ÿ≥ÿ®ÿ® ÿßŸÑÿ∑ÿ±ÿØ**");
  if (!message.guild.member(user)
  .bannable) return message.reply("**ŸÑÿßŸäŸÖŸÉŸÜŸÜŸä ÿ∑ÿ±ÿØ ÿ¥ÿÆÿµ ÿßÿπŸÑŸâ ŸÖŸÜ ÿ±ÿ™ÿ®ÿ™Ÿä Ÿäÿ±ÿ¨Ÿá ÿßÿπÿ∑ÿßÿ° ÿßŸÑÿ®Ÿàÿ™ ÿ±ÿ™ÿ®Ÿá ÿπÿßŸÑŸä**");

  message.guild.member(user).ban(7, user);

  const banembed = new Discord.RichEmbed()
  .setAuthor(`BANNED!`, user.displayAvatarURL)
  .setColor("RANDOM")
  .setTimestamp()
  .addField("**User:**",  '**[ ' + `${user.tag}` + ' ]**')
  .addField("**By:**", '**[ ' + `${message.author.tag}` + ' ]**')
  .addField("**Reason:**", '**[ ' + `${reason}` + ' ]**')
  message.channel.send({
    embed : banembed
  })
}
});







client.on('message', message => {
let perm = message.guild.member(message.author).hasPermission('ADMINISTRATOR') || message.guild.member(message.author).hasPermission('BAN_MEMBERS')
if (!perm) return message.reply(':x: | **You don\'t have `BAN_MEMBERS` permission to use this command**.')
if(message.content.startsWith(prefix + 'hackban')) {
  let nourid = message.content.split(" ").slice(3).join(" ");
  client.fetchUser(nourid).then(id => {
    message.guild.ban(id).catch(err => {
      message.channel.send("Error 404, failed to ban this user :( -> " +id)
      console.log(err)
    })
    message.channel.send(`I banned the user ${id} successfully.`)
  }).catch(() => {
    message.channel.send(`Theres no user with the ID of ${nourid}, please try again. :face_palm:`)
  })
  }});






client.on('message', message => {
let perm = message.guild.member(message.author).hasPermission('ADMINISTRATOR') || message.guild.member(message.author).hasPermission('BAN_MEMBERS')
if (!perm) return message.reply(':x: | **You don\'t have `BAN_MEMBERS` permission to use this command**.')
if(message.content.startsWith(prefix + 'unhackban')) {
  let nourid = message.content.split(" ").slice(3).join(" ");
  let nour = bot.fetchUser(nourid)
  .then(user => {
    message.guild.unban(user.id)
    .then(() => {
      message.channel.send(`Alright, I unhackbanned ${user}.`)
    }).catch(err => {
        message.channel.send(`Failed to unban :( ${user}`)
    })
  }).catch(() => message.channel.send("Theres no user with the this ID :face_palm:"))
}
  })




client.on('message', message => {
    if (message.content.startsWith("S!bans")) {
        message.guild.fetchBans()
        .then(bans => message.channel.send(`${bans.size} ÿπÿØÿØ ÿßÿ¥ÿÆÿßÿµ ÿßŸÑŸÖÿ®ŸÜÿØÿ© ŸÖŸÜ ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ± `))
  .catch(console.error);
}
});





client.on('message', message => {
    if (message.author.id === client.user.id) return;
    if (message.guild) {
   let embed = new Discord.RichEmbed()
    let args = message.content.split(' ').slice(1).join(' ');
if(message.content.split(' ')[0] == prefix + 'bc') {
    if (!args[1]) {
return;
}
        message.guild.members.forEach(m => {
   if(!message.member.hasPermission('ADMINISTRATOR')) return;
            var bc = new Discord.RichEmbed()
            .addField(' ¬ª ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© : ', args)
            .setColor('#ff0000')
            // m.send(`[${m}]`);
            m.send(`${m}`,{embed: bc});
        });
    }
    } else {
        return;
    }
});






client.on('message', message => {
var prefix = "S!";
      if(message.content === prefix + "hchannel") {
      if(!message.channel.guild) return;
      if(!message.member.hasPermission('ADMINISTRATOR')) return message.reply('You Dont Have Perms ‚ùå');
             message.channel.overwritePermissions(message.guild.id, {
             READ_MESSAGES: false
 })
              message.channel.send('Channel Hided Successfully ! ‚úÖ  ')
 }
});






client.on('message', message => {
var prefix = "S!";
      if(message.content === prefix + "schannel") {
      if(!message.channel.guild) return;
      if(!message.member.hasPermission('ADMINISTRATOR')) return message.reply('‚ùå');
             message.channel.overwritePermissions(message.guild.id, {
             READ_MESSAGES: true
 })
              message.channel.send('Done  ')
 }
});




client.on("message", async message => {
        if(!message.channel.guild) return;
 var prefix= "S!";
        if(message.content.startsWith(prefix + 'server')) {
        let guild = message.guild
        let channel = message.channel
        let guildicon = guild.icon_url
        let members = guild.memberCount
        let bots = guild.members.filter(m => m.user.bot).size
        let humans = members - bots
        let allchannels = guild.channels.size
        let textchannels = guild.channels.filter(e => e.type === "text")
        let voicechannels = guild.channels.filter(e => e.type === "voice")
          var embed = new Discord.RichEmbed()
          .setColor("#000000")
          .setTitle(`ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿπŸÜ ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ±`)
          .setDescription(`ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿπŸÜ : ${guild.name}`)
          .addField("ÿµÿßÿ≠ÿ® ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ± :", `${guild.owner}`, true)
          .addField("ÿ£ŸäÿØŸä ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ± :", `${guild.id}`, true)
          .addField("ŸÖŸàŸÇÿπ ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ± :", `${guild.region}`, true)
          .addField("ŸÖÿ≥ÿ™ŸàŸâ ÿ≠ŸÖÿßŸäÿ© ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ± :", `${guild.verificationLevel}`, true)
          .addField("ÿπÿØÿØ ÿßŸÑÿ±ŸàŸÖÿßÿ™ ÿßŸÑÿµŸàÿ™Ÿäÿ© :", `${voicechannels.size}`, true)
          .addField("ÿπÿØÿØ ÿßŸÑÿ±ŸàŸÖÿßÿ™ ÿßŸÑŸÉÿ™ÿßÿ®Ÿäÿ© :", `${textchannels.size}`, true)
          .addField("ÿπÿØÿØ ÿßÿπÿ∂ÿßÿ° ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ± :", `${members}`, true)
          .addField("ÿπÿØÿØ ÿßŸÑÿ®Ÿàÿ™ÿßÿ™ :", `${bots}`, true)
          .addField("ÿπÿØÿØ ÿßŸÑÿßÿ¥ÿÆÿßÿµ :", `${humans}`, true)
          .addField("ÿπÿØÿØ ÿ±ÿ™ÿ® ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ± :", `${guild.roles.size}`, true)
          .addField(`ÿ£ŸäŸÖŸàÿ¨Ÿäÿßÿ™ ÿßŸÑÿÆÿßÿµÿ© ÿ®ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ± : (${guild.emojis.size})`, `- ${guild.emojis.array()}`, true)
          .setFooter(`ÿ™ŸÖ ÿßŸÜÿ¥ÿßÿ° Ÿáÿ∞Ÿá ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ± ŸÅŸä: ${guild.createdAt}`)
 
       message.channel.send({ embed: embed });
 
      }
    });









client.on('message' , message => {
var prefix = "S!"

if (message.author.bot) return;
if (message.content.startsWith(prefix + "contact")) {
if (!message.channel.guild) return;



let args = message.content.split(" ").slice(1).join(" ");



Client.users.get("459806154961453066").send(
    "\n" + "**" + "‚óè ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ± :" + "**" +
    "\n" + "**" + "¬ª " + message.guild.name + "**" +
    "\n" + "**" + " ‚óè ÿßŸÑŸÖÿ±ÿ≥ŸÑ : " + "**" +
    "\n" + "**" + "¬ª " + message.author.tag + "**" +
    "\n" + "**" + " ‚óè ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© : " + "**" +
    "\n" + "**" + args + "**")

let embed = new Discord.RichEmbed()
     .setAuthor(message.author.username, message.author.avatarURL)
     .setDescription('üì¨ ÿ™ŸÖ ÿßÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑŸâ ÿµÿßÿ≠ÿ® ÿßŸÑÿ®Ÿàÿ™ ÿ®ŸÜÿ¨ÿßÿ≠')
     .setThumbnail(message.author.avatarURL)
     .setFooter("By : A7med")
                                                

message.channel.send(embed);


}
    
});




client.on("message", message => {
    var prefix = "S!";
 if (message.content === "S!help") {
  const embed = new Discord.RichEmbed()  
      .setColor("RANDOM")
      .setDescription(`
     
             Please Select Your Language
${prefix}help-ar
${prefix}help-en
             
      `)
   message.channel.sendEmbed(embed)
   
   }
   });
 
   client.on("message", message => {
 if (message.content === "S!help-ar") {
  const embed = new Discord.RichEmbed()  
      .setColor("RANDOM")
      .setDescription(`
     
            ÿßÿÆÿ™ÿ±:
 
S!help-gn-ar ‚áè ÿßŸàÿßŸÖÿ± ÿπÿßŸÖÿ©
S!help-ad-ar ‚áè ÿßŸàÿßŸÖÿ± ÿßÿØÿßÿ±ÿ© ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ±
             
S!help-mu-ar ‚áè ÿßŸàÿßŸÖÿ± ÿßŸÑŸÖŸàÿ≥ŸäŸÇŸâ
`)
message.channel.sendEmbed(embed)
 
}
});
 
client.on("message", message => {
    if (message.content === "S!help-en") {
     const embed = new Discord.RichEmbed()  
         .setColor("RANDOM")
         .setDescription(`
         
              Chose:
               
   S!help-gn-en ‚áè General commands
   
   S!help-ad-en ‚áè Server management commands
               
   S!help-mu-en ‚áè Music commands
   
   
   `)
   message.channel.sendEmbed(embed)
   
   }
   });
 
   client.on("message", message => {
    var prefix = "S!";
 if (message.content === "S!help-gn-ar") {
     message.channel.send('**ÿ™ŸÖ ÿßÿ±ÿ≥ÿßŸÑ ÿ±ÿ≥ÿßŸÑÿ© ŸÅŸä ÿßŸÑÿÆÿßÿµ** :mailbox_with_mail: ');
  const embed = new Discord.RichEmbed()
      .setColor("RANDOM")
      .setDescription(`
             
===================== ÿßŸàÿßŸÖÿ± ÿπÿßŸÖÿ© =====================
S!id ‚ûæ ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿπŸÜ ÿ≠ÿ≥ÿßÿ®ŸÉ
S!ping ‚ûæ ÿ≥ÿ±ÿπÿ© ÿßÿ™ÿµÿßŸÑŸÉ ÿ®ÿßŸÑÿßŸÜÿ™ÿ±ŸÜÿ™
S!avatar ‚ûæ Ÿäÿ∏Ÿáÿ± ÿµŸàÿ±ÿ© ÿ®ÿ±ŸàŸÅÿßÿ®ŸÑŸÉ
S!server ‚ûæ ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿπŸÜ ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ±
S!bot ‚ûæ ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿπŸÜ ÿßŸÑÿ®Ÿàÿ™
S!credit ‚ûæ Ÿäÿ∏Ÿáÿ±ŸÑŸÉ ÿßŸÑŸÉÿ±ÿØÿ™ ÿ≠ŸÇŸÇ
S!daily ‚ûæ ŸäŸàŸÖŸäÿ©
S!trans [@someone] [number] ‚ûæ ŸÑÿ™ÿ≠ŸàŸäŸÑ ŸÉÿ±ÿØÿ™ ŸÑÿ¥ÿÆÿµ ÿßÿÆÿ±
S!count ‚ûæ Ÿäÿπÿ±ÿ∂ŸÑŸÉ ÿπÿØÿØ ÿßŸÑÿßÿ¥ÿÆÿßÿµ ÿßŸÑŸä ÿ®ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ±
S!short ‚ûæ ŸäÿÆÿ™ÿµÿ±ŸÑŸÉ ÿßŸÑÿ±Ÿàÿßÿ®ÿ∑
S!say ‚ûæ ŸäŸÉÿ±ÿ± ŸÉŸÑÿßŸÖŸÉ
S!image ‚ûæ ÿµŸàÿ±ÿ© ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ±
S!contact ‚ûæ ŸÑŸÖÿ±ÿßÿ≥ŸÑŸá ÿµÿßÿ≠ÿ® ÿßŸÑÿ®Ÿàÿ™
S!invites ‚ûæ Ÿäÿπÿ±ÿ∂ŸÑŸÉ ÿπÿØÿØ ÿßŸÜŸÅÿßŸäÿ™ÿßÿ™ŸÉ ÿ®ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ±
S!inv ‚ûæ ÿ±ÿßÿ®ÿ∑ ÿßÿ∞ÿÆÿßŸÑ ÿßŸÑÿ®Ÿàÿ™
S!support ‚ûæ ÿ≥Ÿäÿ±ŸÅÿ± ÿßŸÑÿØÿπŸÖ
=========================================================
ŸàŸÇÿ±Ÿäÿ®ÿßŸã ÿßŸÑŸÖÿ≤ŸäÿØ ŸÖŸÜ ÿßŸÑÿßŸÉŸàÿßÿØ
`)
   message.author.sendEmbed(embed)
   
   }
   });
 
 
 
 
 
   client.on("message", message => {
    var prefix = "S!";
 if (message.content === "S!help-gn-en") {
     message.channel.send('**Check your dm** :mailbox_with_mail: ');
  const embed = new Discord.RichEmbed()
      .setColor("RANDOM")
      .setDescription(`
             
==================== General commands =====================
S!id ‚ûæ your informations
S!ping ‚ûæ your ping
S!avatar ‚ûæ your profile avatar
S!server ‚ûæ server informations
S!bot ‚ûæ bot informations
S!credit ‚ûæ your credits
S!daily ‚ûæ your daily credits
S!trans [@mention] [number] ‚ûæ to transfer credits for someone
S!count ‚ûæ server members without bots
S!short ‚ûæ shorten links
S!say ‚ûæ repeat your words
S!image ‚ûæ server image
S!contact ‚ûæ send text to bot owner
S!invites ‚ûæ to see your invites
S!inv ‚ûæ bot invite link
S!support ‚ûæ support server
=========================================================
More commands soon
`)
   message.author.sendEmbed(embed)
   
   }
   });
 
   client.on("message", message => {
    var prefix = "S!";
 if (message.content === "S!help-ad-ar") {
     message.channel.send('**ÿ™ŸÖ ÿßÿ±ÿ≥ÿßŸÑ ÿ±ÿ≥ÿßŸÑÿ© ÿ®ÿßŸÑÿÆÿßÿµ** :mailbox_with_mail: ');
  const embed = new Discord.RichEmbed()
      .setColor("RANDOM")
      .setDescription(`
             
==================== ÿßŸàÿßŸÖÿ± ÿßÿØÿßÿ±Ÿäÿ© =====================
S!bc ‚ûæ ŸÑÿßÿ±ÿ≥ÿßŸÑ ÿ±ÿ≥ÿßŸÑŸá ŸÑÿ¨ŸÖŸäÿπ ÿßŸÑÿßÿπÿ∂ÿßÿ°
S!ban [@mention] [reason] ‚ûæ  ŸÑÿ≠ÿ∏ÿ± ÿ¥ÿÆÿµ ŸÖŸÜ ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ±
S!kick [@mention] [reason] ‚ûæ ŸÑÿ∑ÿ±ÿØ ÿ¥ÿÆÿµ ŸÖŸÜ ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ±
S!mute [@mention] [reason] ‚ûæ ŸÑÿßÿπÿ∑ÿßÿ° ŸÖŸäŸàÿ™ ŸÑÿπÿ∂Ÿà
S!unmute [@mention] ‚ûæ ŸÑŸÅŸÉ ÿßŸÑŸÖŸäŸàÿ™ ÿπŸÜ ÿπÿ∂Ÿà
S!move [@mention] ‚ûæ ŸÑŸÜŸÇŸÑ ÿπÿ∂Ÿà ŸÑÿ±ŸàŸÖŸÉ ÿßŸÑÿµŸàÿ™Ÿä
S!ccolors [number] ‚ûæ ŸÑÿµŸÜÿπ ÿπÿØÿØ ŸÖŸÜ ÿßŸÑÿßŸÑŸàÿßŸÜ
S!mutechannel ‚ûæ ŸÑÿßŸÇŸÅÿßŸÑ ÿßŸÑÿ¥ÿßÿ™
S!unmutechannel ‚ûæ ŸÑŸÅÿ™ÿ≠ ÿßŸÑÿ¥ÿßÿ™
S!clear ‚ûæ ŸÑŸÖÿ≥ÿ≠ ÿßŸÑÿ¥ÿßÿ™
S!role humans [role name] ‚ûæ ŸÑÿπÿ∑ÿßÿ° ÿ±ÿ™ÿ®ÿ© ŸÑŸÑÿßÿ¥ÿÆÿßÿµ ŸÅŸÇÿ∑
S!role bots [role name] ‚ûæ ŸÑÿßÿπÿ∑ÿßÿ° ÿ±ÿ™ÿ®ÿ© ŸÑŸÑÿ®Ÿàÿ™ÿßÿ™ ŸÅŸÇÿ∑
S!role [@mention] [role name] ‚ûæ ŸÑÿßÿπÿ∑ÿßÿ° ÿ±ÿ™ÿ®ÿ© ŸÑÿπÿ∂Ÿà
S!hchannel ‚ûæ ŸÑÿßÿÆŸÅÿßÿ° ÿßŸÑÿ¥ÿßÿ™
S!schannel ‚ûæ ŸÑÿßÿ∏Ÿáÿßÿ± ÿßŸÑÿ¥ÿßÿ™
=========================================================
ŸàŸÇÿ±Ÿäÿ®ÿßŸã ÿßŸÑŸÖÿ≤ŸäÿØ ŸÖŸÜ ÿßŸÑÿßŸÉŸàÿßÿØ
`)
   message.author.sendEmbed(embed)
   
}
});
 
client.on("message", message => {
 var prefix = "S!";
if (message.content === "S!help-ad-en") {
  message.channel.send('**Check your dm** :mailbox_with_mail: ');
const embed = new Discord.RichEmbed()
   .setColor("RANDOM")
   .setDescription(`
         
==================== Management commands =====================
S!bc ‚ûæ for massage send message to server members
S!ban [@mention] [reason] ‚ûæ to ban someone from the server
S!kick [@mention] [reason] ‚ûæ to kick someone from the server
S!mute [@mention] [reason] ‚ûæ to mute someone
S!unmute [@mention] ‚ûæ to umnute someone
S!move [@mention] ‚ûæ to move someone to your channel
S!ccolors [number] ‚ûæ to create colors
S!mutechannel ‚ûæ to mute chat
S!unmutechannel ‚ûæ to ummute chat
S!clear ‚ûæ to clear chat
S!role humans [role name] ‚ûæ to give role for humans only
S!role bots [role name] ‚ûæ to give role for bots only
S!role [@mention] [role name] ‚ûæ to give role fo someone
S!hchannel ‚ûæ to hide chat
S!schannel ‚ûæ to show chat
=========================================================
More commands soon
`)
message.author.sendEmbed(embed)
 
}
});
 
 
client.on("message", message => {
    var prefix = "S!";
 if (message.content === "S!help-mu-ar") {
     message.channel.send('**ÿ™ŸÖ ÿßÿ±ÿ≥ÿßŸÑ ÿ±ÿ≥ÿßŸÑÿ© ÿ®ÿßŸÑÿÆÿßÿµ** :mailbox_with_mail: ');
  const embed = new Discord.RichEmbed()
      .setColor("RANDOM")
      .setDescription(`
             
==================== ÿßŸàÿßŸÖÿ± ÿßŸÑŸÖŸäŸàÿ≤ŸÉ =====================
S!play ‚ûæ ŸÑÿ™ÿ¥ÿ∫ŸäŸÑ ÿßÿ∫ŸÜŸäÿ©
S!skip ‚ûæ ŸÑÿ™ÿÆÿ∑Ÿä ÿßÿ∫ŸÜŸäÿ©
S!pause ‚ûæ ŸÑÿ•ŸäŸÇÿ¢ŸÅ ÿßŸÑÿ£ÿ∫ŸÜŸäÿ© ŸÖÿ§ŸÇÿ™ÿß
S!resume ‚ûæ ŸÑÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿßÿ∫ŸÜŸÜŸäÿ©
S!vol ‚ûæ ŸÑÿ™ÿ∫Ÿäÿ± ŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑÿµŸàÿ™ 0 - 100
S!stop ‚ûæ ŸÑÿßÿÆÿ±ÿßÿ¨ ÿßŸÑÿ®Ÿàÿ™ ŸÖŸÜ ÿßŸÑÿ±ŸàŸÖ
S!np ‚ûæ ŸÑŸÖÿπÿ±ŸÅÿ© ÿßŸÑÿßÿ∫ŸÜŸäÿ© ŸÖÿ¥ÿ∫ŸÑÿ©
S!queue ‚ûæ ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿßÿ∫ÿßŸÜŸä
 
=========================================================
ŸàŸÇÿ±Ÿäÿ®ÿßŸã ÿßŸÑŸÖÿ≤ŸäÿØ ŸÖŸÜ ÿßŸÑÿßŸÉŸàÿßÿØ
`)
   message.author.sendEmbed(embed)
   
}
});
 
 
client.on("message", message => {
    var prefix = "S!";
 if (message.content === "S!help-mu-en") {
     message.channel.send('**Check your dm** :mailbox_with_mail: ');
  const embed = new Discord.RichEmbed()
      .setColor("RANDOM")
      .setDescription(`
             
==================== Music commands =====================
S!play ‚ûæ to play song
S!skip ‚ûæ to skip song
S!pause ‚ûæ to pause the song
S!resume ‚ûæ To resume the song
S!vol ‚ûæ to change the volume 0 - 100
S!stop ‚ûæ top remove the bot from room
S!np ‚ûæ to show the song that is currently playing
S!queue ‚ûæ to see the song list
 
=========================================================
More codes soon
`)
   message.author.sendEmbed(embed)
   
}
});





client.on("guildMemberAdd", member => {
  member.createDM().then(function (channel) {
  return channel.send(`:rose:  ŸàŸÑŸÉŸÖ ŸÜŸàÿ±ÿ™ ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ±:rose: 
:crown:ÿßÿ≥ŸÖ ÿßŸÑÿπÿ∂Ÿà  ${member}:crown:  
ÿßŸÜÿ™ ÿßŸÑÿπÿ∂Ÿà ÿ±ŸÇŸÖ ${member.guild.memberCount} `) 
}).catch(console.error)
})







 
 
 


const forEachTimeout = require('foreach-timeout');
const colors = ["FF0D00","00FFFF","DC143C","FF4F00","008B8B","FF6C00","DAA520","FF8300","7FFF00","FF9500","8A2BE2","FFA500","00008B","00BFFF","FFBB00","FF1493","8B0000","006400"];
const stop = [];
async function color () {
    forEachTimeout(colors, (color) => {
        client.guilds.forEach((guild) => {
                if (!stop.includes(guild.id)) {
                let role = guild.roles.find('name', 'rainbow');
                if (role && role.editable) 
                    role.setColor(color);
            }  
        });
    }, 1500).then(color);
}
client.on('ready', () => {
    color();
});
client.on('message', (message) => {
    if (message.channel.type !== 'text') return;
    if (message.member.hasPermission('MANAGE_GUILD') || message.member.hasPermission('ADMINISTRATOR') || message.member.id === message.guild.owner.id) {
        if (message.content === 'S!stop') {stop.push(message.guild.id); return message.channel.send('–ì–æ—Ç–æ–≤–æ');}
        if (message.content === 'S!start') {stop.splice(stop.indexOf(message.guild.id),1); return message.channel.send('–ì–æ—Ç–æ–≤–æ');}
    }
})



client.on('messageDelete', message => {
 
    if(message.author.bot) return;
    if(message.channel.type === 'dm') return;
    if(!message.guild.member(client.user).hasPermission('EMBED_LINKS')) return;
    if(!message.guild.member(client.user).hasPermission('MANAGE_MESSAGES')) return;
 
    var logChannel = message.guild.channels.find(c => c.name === 'log');
    if(!logChannel) return;
 
    let messageDelete = new Discord.RichEmbed()
    .setTitle('**[MESSAGE DELETE]**')
    .setColor('RED')
    .setThumbnail(message.author.avatarURL)
    .setDescription(`**\n**:wastebasket: Successfully \`\`DELETE\`\` **MESSAGE** In ${message.channel}\n\n**Channel:** \`\`${message.channel.name}\`\` (ID: ${message.channel.id})\n**Message ID:** ${message.id}\n**Sent By:** <@${message.author.id}> (ID: ${message.author.id})\n**Message:**\n\`\`\`${message}\`\`\``)
    .setTimestamp()
    .setFooter(message.guild.name, message.guild.iconURL)
 
    logChannel.send(messageDelete);
});
client.on('messageUpdate', (oldMessage, newMessage) => {
 
    if(oldMessage.author.bot) return;
    if(!oldMessage.channel.type === 'dm') return;
    if(!oldMessage.guild.member(client.user).hasPermission('EMBED_LINKS')) return;
    if(!oldMessage.guild.member(client.user).hasPermission('MANAGE_MESSAGES')) return;
 
    var logChannel = oldMessage.guild.channels.find(c => c.name === 'log');
    if(!logChannel) return;
 
    if(oldMessage.content.startsWith('https://')) return;
 
    let messageUpdate = new Discord.RichEmbed()
    .setTitle('**[MESSAGE EDIT]**')
    .setThumbnail(oldMessage.author.avatarURL)
    .setColor('BLUE')
    .setDescription(`**\n**:wrench: Successfully \`\`EDIT\`\` **MESSAGE** In ${oldMessage.channel}\n\n**Channel:** \`\`${oldMessage.channel.name}\`\` (ID: ${oldMessage.channel.id})\n**Message ID:** ${oldMessage.id}\n**Sent By:** <@${oldMessage.author.id}> (ID: ${oldMessage.author.id})\n\n**Old Message:**\`\`\`${oldMessage}\`\`\`\n**New Message:**\`\`\`${newMessage}\`\`\``)
    .setTimestamp()
    .setFooter(oldMessage.guild.name, oldMessage.guild.iconURL)
 
    logChannel.send(messageUpdate);
});
 
 
client.on('roleCreate', role => {
 
    if(!role.guild.member(client.user).hasPermission('EMBED_LINKS')) return;
    if(!role.guild.member(client.user).hasPermission('VIEW_AUDIT_LOG')) return;
 
    var logChannel = role.guild.channels.find(c => c.name === 'log');
    if(!logChannel) return;
 
    role.guild.fetchAuditLogs().then(logs => {
        var userID = logs.entries.first().executor.id;
        var userAvatar = logs.entries.first().executor.avatarURL;
 
        let roleCreate = new Discord.RichEmbed()
        .setTitle('**[ROLE CREATE]**')
        .setThumbnail(userAvatar)
        .setDescription(`**\n**:white_check_mark: Successfully \`\`CREATE\`\` Role.\n\n**Role Name:** \`\`${role.name}\`\` (ID: ${role.id})\n**By:** <@${userID}> (ID: ${userID})`)
        .setColor('GREEN')
        .setTimestamp()
        .setFooter(role.guild.name, role.guild.iconURL)
 
        logChannel.send(roleCreate);
    })
});
client.on('roleDelete', role => {
 
    if(!role.guild.member(client.user).hasPermission('EMBED_LINKS')) return;
    if(!role.guild.member(client.user).hasPermission('VIEW_AUDIT_LOG')) return;
 
    var logChannel = role.guild.channels.find(c => c.name === 'log');
    if(!logChannel) return;
 
    role.guild.fetchAuditLogs().then(logs => {
        var userID = logs.entries.first().executor.id;
        var userAvatar = logs.entries.first().executor.avatarURL;
 
        let roleDelete = new Discord.RichEmbed()
        .setTitle('**[ROLE DELETE]**')
        .setThumbnail(userAvatar)
        .setDescription(`**\n**:white_check_mark: Successfully \`\`DELETE\`\` Role.\n\n**Role Name:** \`\`${role.name}\`\` (ID: ${role.id})\n**By:** <@${userID}> (ID: ${userID})`)
        .setColor('RED')
        .setTimestamp()
        .setFooter(role.guild.name, role.guild.iconURL)
 
        logChannel.send(roleDelete);
    })
});
 
 
client.on('channelCreate', channel => {
 
    if(!channel.guild) return;
    if(!channel.guild.member(client.user).hasPermission('EMBED_LINKS')) return;
    if(!channel.guild.member(client.user).hasPermission('VIEW_AUDIT_LOG')) return;
 
    var logChannel = channel.guild.channels.find(c => c.name === 'log');
    if(!logChannel) return;
 
    if(channel.type === 'text') {
        var roomType = 'Text';
    }else
    if(channel.type === 'voice') {
        var roomType = 'Voice';
    }else
    if(channel.type === 'category') {
        var roomType = 'Category';
    }
 
    channel.guild.fetchAuditLogs().then(logs => {
        var userID = logs.entries.first().executor.id;
        var userAvatar = logs.entries.first().executor.avatarURL;
 
        let channelCreate = new Discord.RichEmbed()
        .setTitle('**[CHANNEL CREATE]**')
        .setThumbnail(userAvatar)
        .setDescription(`**\n**:white_check_mark: Successfully \`\`CREATE\`\` **${roomType}** channel.\n\n**Channel Name:** \`\`${channel.name}\`\` (ID: ${channel.id})\n**By:** <@${userID}> (ID: ${userID})`)
        .setColor('GREEN')
        .setTimestamp()
        .setFooter(channel.guild.name, channel.guild.iconURL)
 
        logChannel.send(channelCreate);
    })
});
client.on('channelDelete', channel => {
    if(!channel.guild) return;
    if(!channel.guild.member(client.user).hasPermission('EMBED_LINKS')) return;
    if(!channel.guild.member(client.user).hasPermission('VIEW_AUDIT_LOG')) return;
 
    var logChannel = channel.guild.channels.find(c => c.name === 'log');
    if(!logChannel) return;
 
    if(channel.type === 'text') {
        var roomType = 'Text';
    }else
    if(channel.type === 'voice') {
        var roomType = 'Voice';
    }else
    if(channel.type === 'category') {
        var roomType = 'Category';
    }
 
    channel.guild.fetchAuditLogs().then(logs => {
        var userID = logs.entries.first().executor.id;
        var userAvatar = logs.entries.first().executor.avatarURL;
 
        let channelDelete = new Discord.RichEmbed()
        .setTitle('**[CHANNEL DELETE]**')
        .setThumbnail(userAvatar)
        .setDescription(`**\n**:white_check_mark: Successfully \`\`DELETE\`\` **${roomType}** channel.\n\n**Channel Name:** \`\`${channel.name}\`\` (ID: ${channel.id})\n**By:** <@${userID}> (ID: ${userID})`)
        .setColor('RED')
        .setTimestamp()
        .setFooter(channel.guild.name, channel.guild.iconURL)
 
        logChannel.send(channelDelete);
    })
});
client.on('channelUpdate', (oldChannel, newChannel) => {
    if(!oldChannel.guild) return;
 
    var logChannel = oldChannel.guild.channels.find(c => c.name === 'log');
    if(!logChannel) return;
 
    if(oldChannel.type === 'text') {
        var channelType = 'Text';
    }else
    if(oldChannel.type === 'voice') {
        var channelType = 'Voice';
    }else
    if(oldChannel.type === 'category') {
        var channelType = 'Category';
    }
 
    oldChannel.guild.fetchAuditLogs().then(logs => {
        var userID = logs.entries.first().executor.id;
        var userAvatar = logs.entries.first().executor.avatarURL;
 
        if(oldChannel.name !== newChannel.name) {
            let newName = new Discord.RichEmbed()
            .setTitle('**[CHANNEL EDIT]**')
            .setThumbnail(userAvatar)
            .setColor('BLUE')
            .setDescription(`**\n**:wrench: Successfully Edited **${channelType}** Channel Name\n\n**Old Name:** \`\`${oldChannel.name}\`\`\n**New Name:** \`\`${newChannel.name}\`\`\n**Channel ID:** ${oldChannel.id}\n**By:** <@${userID}> (ID: ${userID})`)
            .setTimestamp()
            .setFooter(oldChannel.guild.name, oldChannel.guild.iconURL)
 
            logChannel.send(newName);
        }
        if(oldChannel.topic !== newChannel.topic) {
            let newTopic = new Discord.RichEmbed()
            .setTitle('**[CHANNEL EDIT]**')
            .setThumbnail(userAvatar)
            .setColor('BLUE')
            .setDescription(`**\n**:wrench: Successfully Edited **${channelType}** Channel Topic\n\n**Old Topic:**\n\`\`\`${oldChannel.topic || 'NULL'}\`\`\`\n**New Topic:**\n\`\`\`${newChannel.topic || 'NULL'}\`\`\`\n**Channel:** ${oldChannel} (ID: ${oldChannel.id})\n**By:** <@${userID}> (ID: ${userID})`)
            .setTimestamp()
            .setFooter(oldChannel.guild.name, oldChannel.guild.iconURL)
 
            logChannel.send(newTopic);
        }
    })
});
 
 
client.on('guildBanAdd', (guild, user) => {
 
    if(!guild.member(client.user).hasPermission('EMBED_LINKS')) return;
    if(!guild.member(client.user).hasPermission('VIEW_AUDIT_LOG')) return;
 
    var logChannel = guild.channels.find(c => c.name === 'log');
    if(!logChannel) return;
 
    guild.fetchAuditLogs().then(logs => {
        var userID = logs.entries.first().executor.id;
        var userAvatar = logs.entries.first().executor.avatarURL;
 
        if(userID === client.user.id) return;
 
        let banInfo = new Discord.RichEmbed()
        .setTitle('**[BANNED]**')
        .setThumbnail(userAvatar)
        .setColor('DARK_RED')
        .setDescription(`**\n**:airplane: Successfully \`\`BANNED\`\` **${user.username}** From the server!\n\n**User:** <@${user.id}> (ID: ${user.id})\n**By:** <@${userID}> (ID: ${userID})`)
        .setTimestamp()
        .setFooter(guild.name, guild.iconURL)
 
        logChannel.send(banInfo);
    })
});
client.on('guildBanRemove', (guild, user) => {
    if(!guild.member(client.user).hasPermission('EMBED_LINKS')) return;
    if(!guild.member(client.user).hasPermission('VIEW_AUDIT_LOG')) return;
 
    var logChannel = guild.channels.find(c => c.name === 'log');
    if(!logChannel) return;
 
    guild.fetchAuditLogs().then(logs => {
        var userID = logs.entries.first().executor.id;
        var userAvatar = logs.entries.first().executor.avatarURL;
 
        if(userID === client.user.id) return;
 
        let unBanInfo = new Discord.RichEmbed()
        .setTitle('**[UNBANNED]**')
        .setThumbnail(userAvatar)
        .setColor('GREEN')
        .setDescription(`**\n**:unlock: Successfully \`\`UNBANNED\`\` **${user.username}** From the server\n\n**User:** <@${user.id}> (ID: ${user.id})\n**By:** <@${userID}> (ID: ${userID})`)
        .setTimestamp()
        .setFooter(guild.name, guild.iconURL)
 
        logChannel.send(unBanInfo);
    })
});
client.on('guildUpdate', (oldGuild, newGuild) => {
 
    if(!oldGuild.member(client.user).hasPermission('EMBED_LINKS')) return;
    if(!oldGuild.member(client.user).hasPermission('VIEW_AUDIT_LOG')) return;
 
    var logChannel = oldGuild.channels.find(c => c.name === 'log');
    if(!logChannel) return;
 
    oldGuild.fetchAuditLogs().then(logs => {
        var userID = logs.entries.first().executor.id;
        var userAvatar = logs.entries.first().executor.avatarURL;
 
        if(oldGuild.name !== newGuild.name) {
            let guildName = new Discord.RichEmbed()
            .setTitle('**[CHANGE GUILD NAME]**')
            .setThumbnail(userAvatar)
            .setColor('BLUE')
            .setDescription(`**\n**:white_check_mark: Successfully \`\`EDITED\`\` The guild name.\n\n**Old Name:** \`\`${oldGuild.name}\`\`\n**New Name:** \`\`${newGuild.name}\`\`\n**By:** <@${userID}> (ID: ${userID})`)
            .setTimestamp()
            .setFooter(newGuild.name, oldGuild.iconURL)
 
            logChannel.send(guildName)
        }
        if(oldGuild.region !== newGuild.region) {
            let guildRegion = new Discord.RichEmbed()
            .setTitle('**[CHANGE GUILD REGION]**')
            .setThumbnail(userAvatar)
            .setColor('BLUE')
            .setDescription(`**\n**:white_check_mark: Successfully \`\`EDITED\`\` The guild region.\n\n**Old Region:** ${oldGuild.region}\n**New Region:** ${newGuild.region}\n**By:** <@${userID}> (ID: ${userID})`)
            .setTimestamp()
            .setFooter(oldGuild.name, oldGuild.iconURL)
 
            logChannel.send(guildRegion);
        }
        if(oldGuild.verificationLevel !== newGuild.verificationLevel) {
            if(oldGuild.verificationLevel === 0) {
                var oldVerLvl = 'Very Easy';
            }else
            if(oldGuild.verificationLevel === 1) {
                var oldVerLvl = 'Easy';
            }else
            if(oldGuild.verificationLevel === 2) {
                var oldVerLvl = 'Medium';
            }else
            if(oldGuild.verificationLevel === 3) {
                var oldVerLvl = 'Hard';
            }else
            if(oldGuild.verificationLevel === 4) {
                var oldVerLvl = 'Very Hard';
            }
 
            if(newGuild.verificationLevel === 0) {
                var newVerLvl = 'Very Easy';
            }else
            if(newGuild.verificationLevel === 1) {
                var newVerLvl = 'Easy';
            }else
            if(newGuild.verificationLevel === 2) {
                var newVerLvl = 'Medium';
            }else
            if(newGuild.verificationLevel === 3) {
                var newVerLvl = 'Hard';
            }else
            if(newGuild.verificationLevel === 4) {
                var newVerLvl = 'Very Hard';
            }
 
            let verLog = new Discord.RichEmbed()
            .setTitle('**[GUILD VERIFICATION LEVEL CHANGE]**')
            .setThumbnail(userAvatar)
            .setColor('BLUE')
            .setDescription(`**\n**:white_check_mark: Successfully \`\`EDITED\`\` Guild Verification level.\n\n**Old Verification Level:** ${oldVerLvl}\n**New Verification Level:** ${newVerLvl}\n**By:** <@${userID}> (ID: ${userID})`)
            .setTimestamp()
            .setFooter(oldGuild.name, oldGuild.iconURL)
 
            logChannel.send(verLog);
        }
    })
});
client.on('guildMemberUpdate', (oldMember, newMember) => {
    if(!oldMember.guild) return;
 
    var logChannel = oldMember.guild.channels.find(c => c.name === 'log');
    if(!logChannel) return;
 
    oldMember.guild.fetchAuditLogs().then(logs => {
        var userID = logs.entries.first().executor.id;
        var userAvatar = logs.entries.first().executor.avatarURL;
        var userTag = logs.entries.first().executor.tag;
 
        if(oldMember.nickname !== newMember.nickname) {
            if(oldMember.nickname === null) {
                var oldNM = '`ÿßÿ≥ŸÖŸá ÿßŸÑÿßÿµŸÑŸä`';
            }else {
                var oldNM = oldMember.nickname;
            }
            if(newMember.nickname === null) {
                var newNM = '`ÿßÿ≥ŸÖŸá ÿßŸÑÿßÿµŸÑŸä`';
            }else {
                var newNM = newMember.nickname;
            }
 
            let updateNickname = new Discord.RichEmbed()
            .setTitle('**[UPDATE MEMBER NICKNAME]**')
            .setThumbnail(userAvatar)
            .setColor('BLUE')
            .setDescription(`**\n**:spy: Successfully \`\`CHANGE\`\` Member Nickname.\n\n**User:** ${oldMember} (ID: ${oldMember.id})\n**Old Nickname:** ${oldNM}\n**New Nickname:** ${newNM}\n**By:** <@${userID}> (ID: ${userID})`)
            .setTimestamp()
            .setFooter(oldMember.guild.name, oldMember.guild.iconURL)
 
            logChannel.send(updateNickname);
        }
        if(oldMember.roles.size < newMember.roles.size) {
            let role = newMember.roles.filter(r => !oldMember.roles.has(r.id)).first();
 
            let roleAdded = new Discord.RichEmbed()
            .setTitle('**[ADDED ROLE TO MEMBER]**')
            .setThumbnail(oldMember.guild.iconURL)
            .setColor('GREEN')
            .setDescription(`**\n**:white_check_mark: Successfully \`\`ADDED\`\` Role to **${oldMember.user.username}**\n\n**User:** <@${oldMember.id}> (ID: ${oldMember.user.id})\n**Role:** \`\`${role.name}\`\` (ID: ${role.id})\n**By:** <@${userID}> (ID: ${userID})`)
            .setTimestamp()
            .setFooter(userTag, userAvatar)
 
            logChannel.send(roleAdded);
        }
        if(oldMember.roles.size > newMember.roles.size) {
            let role = oldMember.roles.filter(r => !newMember.roles.has(r.id)).first();
 
            let roleRemoved = new Discord.RichEmbed()
            .setTitle('**[REMOVED ROLE FROM MEMBER]**')
            .setThumbnail(oldMember.guild.iconURL)
            .setColor('RED')
            .setDescription(`**\n**:negative_squared_cross_mark: Successfully \`\`REMOVED\`\` Role from **${oldMember.user.username}**\n\n**User:** <@${oldMember.user.id}> (ID: ${oldMember.id})\n**Role:** \`\`${role.name}\`\` (ID: ${role.id})\n**By:** <@${userID}> (ID: ${userID})`)
            .setTimestamp()
            .setFooter(userTag, userAvatar)
 
            logChannel.send(roleRemoved);
        }
    })
    if(oldMember.guild.owner.id !== newMember.guild.owner.id) {
        let newOwner = new Discord.RichEmbed()
        .setTitle('**[UPDATE GUILD OWNER]**')
        .setThumbnail(oldMember.guild.iconURL)
        .setColor('GREEN')
        .setDescription(`**\n**:white_check_mark: Successfully \`\`TRANSFER\`\` The Owner Ship.\n\n**Old Owner:** <@${oldMember.user.id}> (ID: ${oldMember.user.id})\n**New Owner:** <@${newMember.user.id}> (ID: ${newMember.user.id})`)
        .setTimestamp()
        .setFooter(oldMember.guild.name, oldMember.guild.iconURL)
 
        logChannel.send(newOwner);
    }
});
 
 
client.on('voiceStateUpdate', (voiceOld, voiceNew) => {
 
    if(!voiceOld.guild.member(client.user).hasPermission('EMBED_LINKS')) return;
    if(!voiceOld.guild.member(client.user).hasPermission('VIEW_AUDIT_LOG')) return;
 
    var logChannel = voiceOld.guild.channels.find(c => c.name === 'log');
    if(!logChannel) return;
 
    voiceOld.guild.fetchAuditLogs().then(logs => {
        var userID = logs.entries.first().executor.id;
        var userTag = logs.entries.first().executor.tag;
        var userAvatar = logs.entries.first().executor.avatarURL;
 
        if(voiceOld.serverMute === false && voiceNew.serverMute === true) {
            let serverMutev = new Discord.RichEmbed()
            .setTitle('**[VOICE MUTE]**')
            .setThumbnail('https://images-ext-1.discordapp.net/external/pWQaw076OHwVIFZyeFoLXvweo0T_fDz6U5C9RBlw_fQ/https/cdn.pg.sa/UosmjqDNgS.png')
            .setColor('RED')
            .setDescription(`**User:** ${voiceOld} (ID: ${voiceOld.id})\n**By:** <@${userID}> (ID: ${userID})\n**Channel:** \`\`${voiceOld.voiceChannel.name}\`\` (ID: ${voiceOld.voiceChannel.id})`)
            .setTimestamp()
            .setFooter(userTag, userAvatar)
 
            logChannel.send(serverMutev);
        }
        if(voiceOld.serverMute === true && voiceNew.serverMute === false) {
            let serverUnmutev = new Discord.RichEmbed()
            .setTitle('**[VOICE UNMUTE]**')
            .setThumbnail('https://images-ext-1.discordapp.net/external/u2JNOTOc1IVJGEb1uCKRdQHXIj5-r8aHa3tSap6SjqM/https/cdn.pg.sa/Iy4t8H4T7n.png')
            .setColor('GREEN')
            .setDescription(`**User:** ${voiceOld} (ID: ${voiceOld.id})\n**By:** <@${userID}> (ID: ${userID})\n**Channel:** \`\`${voiceOld.voiceChannel.name}\`\` (ID: ${voiceOld.voiceChannel.id})`)
            .setTimestamp()
            .setFooter(userTag, userAvatar)
 
            logChannel.send(serverUnmutev);
        }
        if(voiceOld.serverDeaf === false && voiceNew.serverDeaf === true) {
            let serverDeafv = new Discord.RichEmbed()
            .setTitle('**[VOICE DEAF]**')
            .setThumbnail('https://images-ext-1.discordapp.net/external/7ENt2ldbD-3L3wRoDBhKHb9FfImkjFxYR6DbLYRjhjA/https/cdn.pg.sa/auWd5b95AV.png')
            .setColor('RED')
            .setDescription(`**User:** ${voiceOld} (ID: ${voiceOld.id})\n**By:** <@${userID}> (ID: ${userID})\n**Channel:** \`\`${voiceOld.voiceChannel.name}\`\` (ID: ${voiceOld.voiceChannel.id})`)
            .setTimestamp()
            .setFooter(userTag, userAvatar)
 
            logChannel.send(serverDeafv);
        }
        if(voiceOld.serverDeaf === true && voiceNew.serverDeaf === false) {
            let serverUndeafv = new Discord.RichEmbed()
            .setTitle('**[VOICE UNDEAF]**')
            .setThumbnail('https://images-ext-2.discordapp.net/external/s_abcfAlNdxl3uYVXnA2evSKBTpU6Ou3oimkejx3fiQ/https/cdn.pg.sa/i7fC8qnbRF.png')
            .setColor('GREEN')
            .setDescription(`**User:** ${voiceOld} (ID: ${voiceOld.id})\n**By:** <@${userID}> (ID: ${userID})\n**Channel:** \`\`${voiceOld.voiceChannel.name}\`\` (ID: ${voiceOld.voiceChannel.id})`)
            .setTimestamp()
            .setFooter(userTag, userAvatar)
 
            logChannel.send(serverUndeafv);
        }
    })
    if(voiceOld.voiceChannelID !== voiceNew.voiceChannelID && !voiceOld.voiceChannel) {
        let voiceJoin = new Discord.RichEmbed()
        .setTitle('**[JOIN VOICE ROOM]**')
        .setColor('GREEN')
        .setThumbnail(voiceOld.user.avatarURL)
        .setDescription(`**\n**:arrow_lower_right: Successfully \`\`JOIN\`\` To Voice Channel.\n\n**Channel:** \`\`${voiceNew.voiceChannel.name}\`\` (ID: ${voiceNew.voiceChannelID})\n**User:** ${voiceOld} (ID: ${voiceOld.id})`)
        .setTimestamp()
        .setFooter(voiceOld.user.tag, voiceOld.user.avatarURL)
 
        logChannel.send(voiceJoin);
    }
    if(voiceOld.voiceChannelID !== voiceNew.voiceChannelID && !voiceNew.voiceChannel) {
        let voiceLeave = new Discord.RichEmbed()
        .setTitle('**[LEAVE VOICE ROOM]**')
        .setColor('GREEN')
        .setThumbnail(voiceOld.user.avatarURL)
        .setDescription(`**\n**:arrow_upper_left: Successfully \`\`LEAVE\`\` From Voice Channel.\n\n**Channel:** \`\`${voiceOld.voiceChannel.name}\`\` (ID: ${voiceOld.voiceChannelID})\n**User:** ${voiceOld} (ID: ${voiceOld.id})`)
        .setTimestamp()
        .setFooter(voiceOld.user.tag, voiceOld.user.avatarURL)
 
        logChannel.send(voiceLeave);
    }
    if(voiceOld.voiceChannelID !== voiceNew.voiceChannelID && voiceNew.voiceChannel && voiceOld.voiceChannel != null) {
        let voiceLeave = new Discord.RichEmbed()
        .setTitle('**[CHANGED VOICE ROOM]**')
        .setColor('GREEN')
        .setThumbnail(voiceOld.user.avatarURL)
        .setDescription(`**\n**:repeat: Successfully \`\`CHANGED\`\` The Voice Channel.\n\n**From:** \`\`${voiceOld.voiceChannel.name}\`\` (ID: ${voiceOld.voiceChannelID})\n**To:** \`\`${voiceNew.voiceChannel.name}\`\` (ID: ${voiceNew.voiceChannelID})\n**User:** ${voiceOld} (ID: ${voiceOld.id})`)
        .setTimestamp()
        .setFooter(voiceOld.user.tag, voiceOld.user.avatarURL)
 
        logChannel.send(voiceLeave);
    }
});



client.on('message', message => {
  if(message.content === 'S!support') {
  const embed = new Discord.RichEmbed()
  .setTitle('Click here')
  .setURL('https://discord.gg/fKEdPM ')
  .setColor('RANDOM')
  message.channel.send({embed: embed});
  }
});




const db = require('quick.db');   
const giphy = require('giphy-api')();    
const googl = require('goo.gl');  
const translate = require('google-translate-api');   
const fs = require("fs"); 
const getYoutubeID = require('get-youtube-id'); 
const moment = require("moment");  
const { Client, Util } = require('discord.js');  
const UserBlocked = new Set(); 
const jimp = require('jimp');   
const math = require('math-expression-evaluator'); 
const stripIndents = require('common-tags').stripIndents;
const figlet = require('figlet');
const google = require('google-it'); 
const queue = new Map(); 
const zalgo = require('zalgolize');   
const fetchVideoInfo = require('youtube-info');
const YouTube = require('simple-youtube-api');
const ytdl = require('ytdl-core');
const youtube = new YouTube("AIzaSyAdORXg7UZUo7sePv97JyoDqtQVi3Ll0b8");
const sql = require("sqlite");
 const dateFormat = require('dateformat'); 
 const pretty = require('pretty-ms') 

//ÿ≥ŸÜÿ≠ÿ™ÿßÿ¨ ŸÉŸÑ ŸáÿØŸá ÿßŸÑÿ™ÿπÿ±ŸäŸÅÿßÿ™ ÿßŸÑÿßŸÜ Ÿà ŸÑÿßÿ≠ŸÇÿß//

const prefix = "S!"
client.on('message', async msg => { 
	if (msg.author.bot) return undefined;
	if (!msg.content.startsWith(prefix)) return undefined;
	const args = msg.content.split(' ');
	const searchString = args.slice(1).join(' ');
	const url = args[1] ? args[1].replace(/<(.+)>/g, '$1') : '';
	const serverQueue = queue.get(msg.guild.id);
	let command = msg.content.toLowerCase().split(" ")[0];
	command = command.slice(prefix.length)
	if (command === `play`) {
		const voiceChannel = msg.member.voiceChannel;
		if (!voiceChannel) return msg.channel.send('Ÿäÿ¨ÿ® ÿ™Ÿàÿ¢ÿ¨ÿØ ÿ≠ÿ∂ÿ±ÿ™ŸÉ ÿ®ÿ±ŸàŸÖ ÿµŸàÿ™Ÿä .');
		const permissions = voiceChannel.permissionsFor(msg.client.user);
		if (!permissions.has('CONNECT')) {
			
			return msg.channel.send('ŸÑÿß Ÿäÿ™Ÿàÿ¢ÿ¨ÿØ ŸÑÿØŸä ÿµŸÑÿßÿ≠Ÿäÿ© ŸÑŸÑÿ™ŸÉŸÑŸÖ ÿ®Ÿáÿ∞ÿ¢ ÿßŸÑÿ±ŸàŸÖ');
		}
		if (!permissions.has('SPEAK')) {
			return msg.channel.send('ŸÑÿß Ÿäÿ™Ÿàÿ¢ÿ¨ÿØ ŸÑÿØŸä ÿµŸÑÿßÿ≠Ÿäÿ© ŸÑŸÑÿ™ŸÉŸÑŸÖ ÿ®Ÿáÿ∞ÿ¢ ÿßŸÑÿ±ŸàŸÖ');
		}

		if (!permissions.has('EMBED_LINKS')) {
			return msg.channel.sendMessage("**Ÿäÿ¨ÿ® ÿ™Ÿàÿ¢ŸÅÿ± ÿ®ÿ±ŸÖÿ¥ŸÜ `EMBED LINKS`ŸÑÿØŸä **")
		}

		if (url.match(/^https?:\/\/(www.youtube.com|youtube.com)\/playlist(.*)$/)) {
			const playlist = await youtube.getPlaylist(url);
			const videos = await playlist.getVideos();
			
			for (const video of Object.values(videos)) {
				const video2 = await youtube.getVideoByID(video.id);
				await handleVideo(video2, msg, voiceChannel, true);
			}
			return msg.channel.send(` **${playlist.title}** ÿ™ŸÖ ÿßŸÑÿ•ÿ∂ÿ¢ŸÅÿ© ÿ•ŸÑŸâ ŸÇÿ£ÿ¶ŸÖÿ© ÿßŸÑÿ™ÿ¥ÿ∫ŸäŸÑ`);
		} else {
			try {

				var video = await youtube.getVideo(url);
			} catch (error) {
				try {
					var videos = await youtube.searchVideos(searchString, 5);
					let index = 0;
					const embed1 = new Discord.RichEmbed()
			        .setDescription(`**ÿßŸÑÿ±ÿ¨ÿ¢ÿ° ŸÖŸÜ ÿ≠ÿ∂ÿ±ÿ™ŸÉ ÿ•ÿÆÿ™Ÿäÿ¢ÿ± ÿ±ŸÇŸÖ ÿßŸÑŸÖŸÇÿ∑ÿπ** :
${videos.map(video2 => `[**${++index} **] \`${video2.title}\``).join('\n')}`)

					.setFooter("Slash Bot")
					msg.channel.sendEmbed(embed1).then(message =>{message.delete(20000)})
					
					try {
						var response = await msg.channel.awaitMessages(msg2 => msg2.content > 0 && msg2.content < 11, {
							maxMatches: 1,
							time: 15000,
							errors: ['time']
						});
					} catch (err) {
						console.error(err);
						return msg.channel.send('ŸÑŸÖ Ÿäÿ™ŸÖ ÿ•ÿÆÿ™Ÿäÿ¢ÿ± ŸÖŸÇÿ∑ÿπ ÿµŸàÿ™Ÿä');
					}
					const videoIndex = parseInt(response.first().content);
					var video = await youtube.getVideoByID(videos[videoIndex - 1].id);
				} catch (err) {
					console.error(err);
					return msg.channel.send(':X: ŸÑÿß Ÿäÿ™ŸàŸÅÿ± ŸÜÿ™ÿ¢ÿ¶ÿ¨ ÿ®ÿ≠ÿ´ ');
				}
			}

			return handleVideo(video, msg, voiceChannel);
		}
	} else if (command === `skip`) {
		if (!msg.member.voiceChannel) return msg.channel.send('ÿ£ŸÜÿ™ ŸÑÿ≥ÿ™ ÿ®ÿ±ŸàŸÖ ÿµŸàÿ™Ÿä .');
		if (!serverQueue) return msg.channel.send('ŸÑÿß Ÿäÿ™ŸàŸÅÿ± ŸÖŸÇÿ∑ÿπ ŸÑÿ™ÿ¨ÿ¢Ÿàÿ≤Ÿá');
		serverQueue.connection.dispatcher.end('ÿ™ŸÖ ÿ™ÿ¨ÿ¢Ÿàÿ≤ Ÿáÿ∞ÿ¢ ÿßŸÑŸÖŸÇÿ∑ÿπ');
		return undefined;
	} else if (command === `stop`) {
		if (!msg.member.voiceChannel) return msg.channel.send('ÿ£ŸÜÿ™ ŸÑÿ≥ÿ™ ÿ®ÿ±ŸàŸÖ ÿµŸàÿ™Ÿä .');
		if (!serverQueue) return msg.channel.send('ŸÑÿß Ÿäÿ™ŸàŸÅÿ± ŸÖŸÇÿ∑ÿπ ŸÑÿ•ŸäŸÇÿ¢ŸÅŸá');
		serverQueue.songs = [];
		serverQueue.connection.dispatcher.end('ÿ™ŸÖ ÿ•ŸäŸÇÿ¢ŸÅ Ÿáÿ∞ÿ¢ ÿßŸÑŸÖŸÇÿ∑ÿπ');
		return undefined;
	} else if (command === `vol`) {
		if (!msg.member.voiceChannel) return msg.channel.send('ÿ£ŸÜÿ™ ŸÑÿ≥ÿ™ ÿ®ÿ±ŸàŸÖ ÿµŸàÿ™Ÿä .');
		if (!serverQueue) return msg.channel.send('ŸÑÿß ŸäŸàÿ¨ÿØ ÿ¥Ÿäÿ° ÿ¥ÿ∫ÿ¢ŸÑ.');
		if (!args[1]) return msg.channel.send(`:loud_sound: ŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑÿµŸàÿ™ **${serverQueue.volume}**`);
		serverQueue.volume = args[1];
		serverQueue.connection.dispatcher.setVolumeLogarithmic(args[1] / 50);
		return msg.channel.send(`:speaker: ÿ™ŸÖ ÿ™ÿ∫Ÿäÿ± ÿßŸÑÿµŸàÿ™ ÿßŸÑŸä **${args[1]}**`);
	} else if (command === `np`) {
		if (!serverQueue) return msg.channel.send('ŸÑÿß ŸäŸàÿ¨ÿØ ÿ¥Ÿäÿ° ÿ≠ÿßŸÑŸä ŸÅ ÿßŸÑÿπŸÖŸÑ.');
		const embedNP = new Discord.RichEmbed()
	.setDescription(`:notes: ÿßŸÑÿßŸÜ Ÿäÿ™ŸÖ ÿ™ÿ¥ÿ∫ŸäŸÑ : **${serverQueue.songs[0].title}**`)
		return msg.channel.sendEmbed(embedNP);
	} else if (command === `queue`) {
		
		if (!serverQueue) return msg.channel.send('ŸÑÿß ŸäŸàÿ¨ÿØ ÿ¥Ÿäÿ° ÿ≠ÿßŸÑŸä ŸÅ ÿßŸÑÿπŸÖŸÑ.');
		let index = 0;
		
		const embedqu = new Discord.RichEmbed()

.setDescription(`**Songs Queue**
${serverQueue.songs.map(song => `**${++index} -** ${song.title}`).join('\n')}
**ÿßŸÑÿßŸÜ Ÿäÿ™ŸÖ ÿ™ÿ¥ÿ∫ŸäŸÑ** ${serverQueue.songs[0].title}`)
		return msg.channel.sendEmbed(embedqu);
	} else if (command === `pause`) {
		if (serverQueue && serverQueue.playing) {
			serverQueue.playing = false;
			serverQueue.connection.dispatcher.pause();
			return msg.channel.send('ÿ™ŸÖ ÿ•ŸäŸÇÿßŸÅ ÿßŸÑŸÖŸàÿ≥ŸäŸÇŸâ ŸÖÿ§ŸÇÿ™ÿß!');
		}
		return msg.channel.send('ŸÑÿß ŸäŸàÿ¨ÿØ ÿ¥Ÿäÿ° ÿ≠ÿßŸÑŸä ŸÅ ÿßŸÑÿπŸÖŸÑ.');
	} else if (command === "resume") {
		if (serverQueue && !serverQueue.playing) {
			serverQueue.playing = true;
			serverQueue.connection.dispatcher.resume();
			return msg.channel.send('ÿßÿ≥ÿ™ÿ£ŸÜŸÅÿ™ ÿßŸÑŸÖŸàÿ≥ŸäŸÇŸâ ÿ®ÿßŸÑŸÜÿ≥ÿ®ÿ© ŸÑŸÉ !');
		}
		return msg.channel.send('ŸÑÿß ŸäŸàÿ¨ÿØ ÿ¥Ÿäÿ° ÿ≠ÿßŸÑŸä ŸÅŸä ÿßŸÑÿπŸÖŸÑ.');
	}

	return undefined;
});

async function handleVideo(video, msg, voiceChannel, playlist = false) {
	const serverQueue = queue.get(msg.guild.id);
	console.log(video);
	
//	console.log('yao: ' + Util.escapeMarkdown(video.thumbnailUrl));
	const song = {
		id: video.id,
		title: Util.escapeMarkdown(video.title),
		url: `https://www.youtube.com/watch?v=${video.id}`
	};
	if (!serverQueue) {
		const queueConstruct = {
			textChannel: msg.channel,
			voiceChannel: voiceChannel,
			connection: null,
			songs: [],
			volume: 5,
			playing: true
		};
		queue.set(msg.guild.id, queueConstruct);

		queueConstruct.songs.push(song);

		try {
			var connection = await voiceChannel.join();
			queueConstruct.connection = connection;
			play(msg.guild, queueConstruct.songs[0]);
		} catch (error) {
			console.error(`I could not join the voice channel: ${error}`);
			queue.delete(msg.guild.id);
			return msg.channel.send(`ŸÑÿß ÿ£ÿ≥ÿ™ÿ∑Ÿäÿπ ÿØÿÆŸàŸÑ Ÿáÿ∞ÿ¢ ÿßŸÑÿ±ŸàŸÖ ${error}`);
		}
	} else {
		serverQueue.songs.push(song);
		console.log(serverQueue.songs);
		if (playlist) return undefined;
		else return msg.channel.send(` **${song.title}** ÿ™ŸÖ ÿßÿ∂ÿßŸÅŸá ÿßŸÑÿßÿ∫ŸÜŸäÿ© ÿßŸÑŸä ÿßŸÑŸÇÿßÿ¶ŸÖÿ©!`);
	}
	return undefined;
}

function play(guild, song) {
	const serverQueue = queue.get(guild.id);

	if (!song) {
		serverQueue.voiceChannel.leave();
		queue.delete(guild.id);
		return;
	}
	console.log(serverQueue.songs);

	const dispatcher = serverQueue.connection.playStream(ytdl(song.url))
		.on('end', reason => {
			if (reason === 'Stream is not generating quickly enough.') console.log('Song ended.');
			else console.log(reason);
			serverQueue.songs.shift();
			play(guild, serverQueue.songs[0]);
		})
		.on('error', error => console.error(error));
	dispatcher.setVolumeLogarithmic(serverQueue.volume / 5);

	serverQueue.textChannel.send(`ÿ®ÿØÿ° ÿ™ÿ¥ÿ∫ŸäŸÑ : **${song.title}**`);
}






client.login(process.env.BOT_TOKEN);
