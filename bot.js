const Discord = require('discord.js');
const client = new Discord.Client();
const fs = require("fs")
const moment = require ("moment")
const prefix = 'S!'

client.on('ready', () => {
  console.log(`Logged in as ${client.user.tag}!`);
client.user.setGame(`Soooon`,"http://twitch.tv/S-F")
  console.log('')
  console.log('')
  console.log('‚ïî[‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê]‚ïó')
  console.log(`[Start] ${new Date()}`);
  console.log('‚ïö[‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê]‚ïù')
  console.log('')
  console.log('‚ïî[‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê]‚ïó');
  console.log(`Logged in as * [ " ${client.user.username} " ]`);
  console.log('')
  console.log('Informations :')
  console.log('')
  console.log(`servers! [ " ${client.guilds.size} " ]`);
  console.log(`Users! [ " ${client.users.size} " ]`);
  console.log(`channels! [ " ${client.channels.size} " ]`);
  console.log('‚ïö[‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê]‚ïù')
  console.log('')
  console.log('‚ïî[‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê]‚ïó')
  console.log(' Bot Is Online')
  console.log('‚ïö[‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê]‚ïù')
  console.log('')
  console.log('')
});

client.on('message', message => {
	 var prefix ="S!";
 if(message.content.startsWith(prefix +"server")){
if(!message.channel.guild) return message.reply(' ');
const millis = new Date().getTime() - message.guild.createdAt.getTime();
const now = new Date();
dateFormat(now, 'dddd, mmmm dS, yyyy, h:MM:ss TT');
const verificationLevels = ['None', 'Low', 'Medium', 'Insane', 'Extreme'];
const days = millis / 1000 / 60 / 60 / 24;
let roles = client.guilds.get(message.guild.id).roles.map(r => r.name);
var embed  = new Discord.RichEmbed()
.setAuthor(uild.iconURL)
.addField("**üÜî Server ID:**", message.guild.id,true)
.addField("**üìÖ Created On**", message.guild.createdAt.toLocaleString(),true)
.addField("**üëë Owned by**",`${message.guild.owner.user.username}#${message.guild.owner.user.discriminator}`)
.addField("üë• Members ",`[${message.guild.memberCount}]`,true)
.addField('**üí¨ Channels **',`**${message.guild.channels.filter(m => m.type === 'text').size}**` + ' text | Voice  '+ `**${message.guild.channels.filter(m => m.type === 'voice').size}** `,true)
.addField("**üåç Others **" , message.guild.region,true)
.addField("** üîê Roles **",`**[${message.guild.roles.size}]** Role `,true)
.setColor('#000000')
message.channel.sendEmbed(embed)

}
});


client.on('message', message => {
    var prefix = "S!";
  if (message.author.x5bz) return;
  if (!message.content.startsWith(prefix)) return;
 
  let command = message.content.split(" ")[0];
  command = command.slice(prefix.length);
 
  let args = message.content.split(" ").slice(1);
 
  if (command == "ban") {
               if(!message.channel.guild) return message.reply('** This command only for servers**');
         
  if(!message.guild.member(message.author).hasPermission("BAN_MEMBERS")) return message.reply("**You Don't Have ` BAN_MEMBERS ` Permission**");
  if(!message.guild.member(client.user).hasPermission("BAN_MEMBERS")) return message.reply("**I Don't Have ` BAN_MEMBERS ` Permission**");
  let user = message.mentions.users.first();
  let reason = message.content.split(" ").slice(2).join(" ");
  /*let b5bzlog = client.channels.find("name", "5bz-log");
 
  if(!b5bzlog) return message.reply("I've detected that this server doesn't have a 5bz-log text channel.");*/
  if (message.mentions.users.size < 1) return message.channel.send(`https://cdn.pg.sa/fjxlms81nk.png`);
  if(!reason) return message.channel.send(`https://cdn.pg.sa/fjxlms81nk.png`);
  if (!message.guild.member(user)
  .bannable) return message.reply(`This User Is Have High Role !`);
 
  message.guild.member(user).ban(7, user);
 
  const banembed = new Discord.RichEmbed()
  .setAuthor(`BANNED!`, user.displayAvatarURL)
  .setColor("RANDOM")
  .setTimestamp()
  .addField("**User:**",  '**[ ' + `${user.tag}` + ' ]**')
  .addField("**By:**", '**[ ' + `${message.author.tag}` + ' ]**')
  .addField("**Reason:**", '**[ ' + `${reason}` + ' ]**')
  message.channel.send({
    embed : banembed
  })
}
});


client.on('message' , message => {
    var prefix = "S!";
    let user = message.mentions.users.first()|| client.users.get(message.content.split(' ')[1])
    if(message.content.startsWith(prefix + 'unban')) {
        if(!message.member.hasPermission('ADMINISTRATOR')) return message.channel.send('‚ùå|**\`ADMINISTRATOR\`ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÑÿØŸäŸÉ ÿ±ÿ™ÿ®ÿ©`**');
        if(!user) return  message.channel.send(`Do this ${prefix} <@ID user> \n or \n ${prefix}unban ID user`);
        message.guild.unban(user);
        message.guild.owner.send(`ŸÑŸÇÿØ ÿ™ŸÖ ŸÅŸÉ ÿßŸÑÿ®ÿßŸÜÿØ ÿπŸÜ ÿßŸÑÿ¥ÿÆÿµ \n ${user} \n By : <@${message.author.id}>`)
        var embed = new Discord.RichEmbed()
        .setThumbnail(message.author.avatarURl)
        .setColor("RANDOM")
        .setTitle('**‚óèUnban** !')
        .addField('**‚óèUser Unban :** ', `${user}` , true)
        .addField('**‚óèBy :**' ,       ` <@${message.author.id}> ` , true)
        .setAuthor(message.guild.name)
        message.channel.sendEmbed(embed)
    }
});









client.on('message', message => {
    if(message.content == ('S!profile')) {    
 
             if (message.channel.type === 'dm') return message.reply('This Command Is Not Avaible In Dm\'s :x:');   
            var Canvas = module.require('canvas');
            var jimp = module.require('jimp');
    
     const w = ['./id1.png','./id2.png','./id3.png','./id4.png','./id5.png'];
    
             let Image = Canvas.Image,
                 canvas = new Canvas(802, 404),
                 ctx = canvas.getContext('2d');
             ctx.patternQuality = 'bilinear';
             ctx.filter = 'bilinear';
             ctx.antialias = 'subpixel';
             ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
             ctx.shadowOffsetY = 2;
             ctx.shadowBlur = 2;
             fs.readFile(`${w[Math.floor(Math.random() * w.length)]}`, function (err, Background) {
                 if (err) return console.log(err);
                 let BG = Canvas.Image;
                 let ground = new Image;
                 ground.src = Background;
                 ctx.drawImage(ground, 0, 0, 802, 404);
    
     })
                                let user = message.mentions.users.first();
          var men = message.mentions.users.first();
             var heg;
             if(men) {
                 heg = men
             } else {
                 heg = message.author
             }
           var mentionned = message.mentions.members.first();
              var h;
             if(mentionned) {
                 h = mentionned
             } else {
                 h = message.member
             }
             var ment = message.mentions.users.first();
             var getvalueof;
             if(ment) {
               getvalueof = ment;
             } else {
               getvalueof = message.author;
             }//ŸÖÿß ÿÆÿµŸÉ ,_,
                                           let url = getvalueof.displayAvatarURL.endsWith(".webp") ? getvalueof.displayAvatarURL.slice(5, -20) + ".png" : getvalueof.displayAvatarURL;
                                             jimp.read(url, (err, ava) => {
                                                 if (err) return console.log(err);
                                                 ava.getBuffer(jimp.MIME_PNG, (err, buf) => {
                                                     if (err) return console.log(err);
                            
                                                             let Avatar = Canvas.Image;
                                                             let ava = new Avatar;
                                                             ava.src = buf;
                                                             ctx.beginPath();
                                                           ctx.drawImage(ava, 335, 3, 160, 169);
                                                     ctx.font = '35px Arial Bold';
                                                     ctx.fontSize = '40px';
                                                     ctx.fillStyle = "#dadada";
                                                     ctx.textAlign = "center";
                                                    
                            
                                                     ctx.font = '30px Arial Bold';
                                                     ctx.fontSize = '30px';
                                                     ctx.fillStyle = "#ffffff";
                                                                             ctx.fillText(`${getvalueof.username}`,655, 170);
                                                                            
                                                                        
                                                          moment.locale('en-ly');        
                                            
                                            
                                                                    ctx.font = '30px Arial';
                                                     ctx.fontSize = '30px';
                                                     ctx.fillStyle = "#ffffff";
                                                                             ctx.fillText(`${moment(h.joinedAt).fromNow()}`,150, 305);
                                                              
                                                              
                                                                                                     ctx.font = '30px Arial';
                                                     ctx.fontSize = '30px';
                                                     ctx.fillStyle = "#ffffff";
                                                                 ctx.fillText(`${moment(heg.createdTimestamp).fromNow()}`,150, 170); 
                            
                                                       let status;
     if (getvalueof.presence.status === 'online') {
         status = 'online';
     } else if (getvalueof.presence.status === 'dnd') {
         status = 'DND';
     } else if (getvalueof.presence.status === 'idle') {
         status = 'idle';
     } else if (getvalueof.presence.status === 'offline') {
         status = 'offline';
     }
     
     
                                          ctx.cont = '35px Arial';
                                          ctx.fontSize = '30px';
                                          ctx.filleStyle = '#ffffff'
                                          ctx.fillText(`${status}`,655,305)
                  
                                                                   ctx.font = 'regular 30px Cairo';
                                                                   ctx.fontSize = '30px';
                                                                   ctx.fillStyle = '#ffffff'
                                                         ctx.fillText(`${h.presence.game === null ? "No Playing" : h.presence.game.name}`,390,390);
                            
                               ctx.font = '35px Arial';
                                                                   ctx.fontSize = '30px';
                                                                   ctx.fillStyle = '#ffffff'
                                                                   ctx.fillText(`#${heg.discriminator}`,390,260)
                            
                                 ctx.beginPath();
                                 ctx.stroke();
                               message.channel.sendFile(canvas.toBuffer());
                            
                            
                          
                            
                             })
                            
                             })
 }
 });
 

client.on('guildMemberAdd', member => {
     const welcomer =  member.guild.channels.find('name', 'welcome');
const w = ['./w1.png'];
 
         let Image = Canvas.Image,
            canvas = new Canvas(400, 200),
            ctx = canvas.getContext('2d');
        fs.readFile(`${w[Math.floor(Math.random() * w.length)]}`, function (err, Background) {
            if (err) return console.log(err);
            let BG = Canvas.Image;
            let ground = new Image;
            ground.src = Background;
            ctx.drawImage(ground, 0, 0, 400, 200);
             
         
 
                let url = member.user.displayAvatarURL.endsWith(".webp") ? member.user.displayAvatarURL.slice(100) + ".png" : member.user.displayAvatarURL;
                jimp.read(url, (err, ava) => {
                    if (err) return console.log(err);
                    ava.getBuffer(jimp.MIME_PNG, (err, buf) => {
                        if (err) return console.log(err);
                       
                        ctx.font = "bold 12px Arial";
                        ctx.fontSize = '20px';
                        ctx.fillStyle = "#f1f1f1";
                        ctx.textAlign = "center";
                        ctx.fillText(`welcome to Slash Community ¬©`, 300, 130);
                       
                        ctx.font = "bold 12px Arial";
                        ctx.fontSize = '20px';
                        ctx.fillStyle = "#f1f1f1";
                        ctx.textAlign = "center";
                        ctx.fillText(member.user.username, 200, 150);
 
                let Avatar = Canvas.Image;
                              let ava = new Avatar;
                              ava.src = buf;
                              ctx.beginPath();
                              ctx.arc(77, 101, 62, 0, Math.PI*2);
                              ctx.stroke();
                                 ctx.clip();
                                 ctx.drawImage(ava, 13, 38, 128, 126);  
                         
               
                             
welcomer.sendFile(canvas.toBuffer())
 
 
 
     
     
                    }  )  
     
                   
 
})
      });                    
});
var dat = JSON.parse("{}");
function forEachObject(obj, func) {
    Object.keys(obj).forEach(function (key) { func(key, obj[key]) });
}
client.on("ready", () => {
    var guild;
    while (!guild)
        guild = client.guilds.get("493862684693889024");
    guild.fetchInvites().then((data) => {
        data.forEach((Invite, key, map) => {
            var Inv = Invite.code;
            dat[Inv] = Invite.uses;
        });
    });
});
 
 
 
client.on("guildMemberAdd", (member) => {
    let channel = member.guild.channels.get("495536448880115712");
    if (!channel) {
        console.log("!the channel id it's not correct");
        return;
    }
    if (member.id == client.user.id) {
        return;
    }
    console.log('-');
    var guild;
    while (!guild)
        guild = client.guilds.get("493862684693889024");
    guild.fetchInvites().then((data) => {
        data.forEach((Invite, key, map) => {
            var Inv = Invite.code;
            if (dat[Inv])
                if (dat[Inv] < Invite.uses) {
                    setTimeout(function() {
 channel.send(`**invited by** ${Invite.inviter} `) ;
                    },1500);
 }
            dat[Inv] = Invite.uses;
       
       });
    });
});




 client.on('guildMemberAdd', member=> {
    member.addRole(member.guild.roles.find("name","Member"));
    }); 


client.on('message', async msg => {
        var user = msg.author;
            var a = msg.guild.roles.find("name", 'Creative Distruction');
        if(!a){
        a = await msg.guild.createRole({
          name: "Creative Distruction",
          color: "#ffffff",
          permissions:[]
        })
 
        }
        var m = msg.guild.roles.find("name", 'Minecraft');
    if(!m){
        m =  await msg.guild.createRole({
          name: "Minecraft",
          color: "#ffffff",
          permissions:[]
        })
        }
        var f = msg.guild.roles.find("name", 'Fortnite');
        if(!f){
        f =  await msg.guild.createRole({
          name: "Fortnite",
          color: "#ffffff",
          permissions:[]
        })
        }
        var b = msg.guild.roles.find("name", 'Brawlhalla');
        if(!b){
        b =  await msg.guild.createRole({
          name: "Brawlhalla",
          color: "#ffffff",
          permissions:[]
        })
        }
        var black = msg.guild.roles.find("name", 'Blacksquad');
    if(!black){
        black =  await msg.guild.createRole({
          name: "Blacksquad",
          color: "#ffffff",
          permissions:[]
        })
        }
        var le = msg.guild.roles.find("name", 'League Of Legends');
    if(!le){
        le =  await msg.guild.createRole({
          name: "League Of Legends",
          color: "#ffffff",
          permissions:[]
        })
        }
        var bn = msg.guild.roles.find("name", 'ROBLOX');
    if(!bn){
        bn =  await msg.guild.createRole({
          name: "ROBLOX",
          color: "#ffffff",
          permissions:[]
        })
        }
var prefix = "S!";
        if (msg.content.startsWith(prefix +'crm')) {
 
        if(!msg.channel.guild) return msg.channel.send('**Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ± ŸÅŸÇÿ∑ ŸÑŸÑÿ≥Ÿäÿ±ŸÅÿ±ÿßÿ™**').then(m => m.delete(5000));
msg.channel.send(`**\n‚öΩ : \` Creative Distruction\`  \nüë∂ :\` Minecraft \` \nüëä  :\` Fortnite \` \nüëå :\`  Brawlhalla\`  \nüç∏ :\` Black Squad\` \nü•Ç :\`League Of Legends\` \nüåï :\`ROBLOX\`**`).then(res => {     res.react('‚öΩ').then(r=>{
     res.react('üë∂').then(r=>{
     res.react('üëä').then(r=>{
     res.react('üëå').then(r=>{
     res.react('üç∏').then(r=>{
     res.react('ü•Ç').then(r=>{
     res.react('üåï').then(r=>{
    let aaa = (reaction ) => reaction.emoji.name === '‚öΩ'&&user.id
    let mmm = (reaction ) => reaction.emoji.name === 'üë∂'&&user.id
    let fff = (reaction ) => reaction.emoji.name === 'üëä'&&user.id
    let bbb = (reaction ) => reaction.emoji.name === 'üëå'&&user.id
    let bbbb = (reaction) => reaction.emoji.name === 'üç∏'&& user.id
    let cn = (reaction) => reaction.emoji.name === 'ü•Ç'&& user.id
    let zg = (reaction) => reaction.emoji.name === 'üåï'&& user.id
 
    let aa = res.createReactionCollector(aaa);
    let mm = res.createReactionCollector(mmm);
    let ff = res.createReactionCollector(fff);
    let bb = res.createReactionCollector(bbb);
    let bl = res.createReactionCollector(bbbb);
    let zgg = res.createReactionCollector(zg);
aa.on("collect", r => {
    msg.guild.member(user.id).addRole(a);
    msg.guild.member(user.id).removeRole(m);
    msg.guild.member(user.id).removeRole(f);
    msg.guild.member(user.id).removeRole(b);
    msg.guild.member(user.id).removeRole(black);
    msg.guild.member(user.id).removeRole(le);
    msg.delete();
    })
mm.on("collect", r => {
    msg.guild.member(user.id).addRole(m);
    msg.guild.member(user.id).removeRole(a);
    msg.guild.member(user.id).removeRole(f);
    msg.guild.member(user.id).removeRole(b);
    msg.guild.member(user.id).removeRole(black);
    msg.guild.member(user.id).removeRole(le);
    msg.delete();
})
ff.on("collect", r => {
    msg.guild.member(user.id).addRole(f);
    msg.guild.member(user.id).removeRole(m);
    msg.guild.member(user.id).removeRole(a);
    msg.guild.member(user.id).removeRole(b);
    msg.guild.member(user.id).removeRole(black);
    msg.guild.member(user.id).removeRole(le);
    msg.delete();
})
bb.on("collect", r => {
    msg.guild.member(user.id).addRole(b);
    msg.guild.member(user.id).removeRole(m);
    msg.guild.member(user.id).removeRole(f);
    msg.guild.member(user.id).removeRole(a);
    msg.guild.member(user.id).removeRole(black);
    msg.guild.member(user.id).removeRole(le);
    msg.delete();
})
bl.on("collect", r => {
    msg.guild.member(user.id).addRole(black);
    msg.guild.member(user.id).removeRole(m);
    msg.guild.member(user.id).removeRole(f);
    msg.guild.member(user.id).removeRole(b);
    msg.guild.member(user.id).removeRole(a);
    msg.guild.member(user.id).removeRole(le);
    msg.delete();
})
cnn.on("collect", r => {
    msg.guild.member(user.id).addRole(le);
    msg.guild.member(user.id).removeRole(m);
    msg.guild.member(user.id).removeRole(f);
    msg.guild.member(user.id).removeRole(b);
    msg.guild.member(user.id).removeRole(a);
    msg.guild.member(user.id).removeRole(black);
    msg.delete();
})
zgg.on("collect", r => {
    msg.guild.member(user.id).addRole(bn);
    msg.guild.member(user.id).removeRole(m);
    msg.guild.member(user.id).removeRole(f);
    msg.guild.member(user.id).removeRole(b);
    msg.guild.member(user.id).removeRole(a);
    msg.guild.member(user.id).removeRole(black);
    msg.guild.member(user.id).removeRole(le);
    msg.delete();
})
 
})
     })
     })
     })
     })
     })
     })
     })
     }
     });



client.on('ready', () => {setInterval(function(){ client.guilds.get("493862684693889024").roles.find("name", '‚áÅ„Äé Special „Äè‚Äè‚Äè‡ºÑ  ‚ù•').edit({color : "RANDOM"})},1000)})
	
	
	

client.on('message', async message => {
  let args = message.content.split(" ");
  if(message.content.startsWith(prefix + "mute")) {
    if(!message.member.hasPermission("MUTE_MEMBERS")) return message.channel.send('').then(msg => {
      msg.delete(3500);
      message.delete(3500);
    });
 
    if(!message.guild.member(client.user).hasPermission("MUTE_MEMBERS")) return message.channel.send('').then(msg => {
      msg.delete(3500);
      message.delete(3500);
    });
 
    let mention = message.mentions.members.first();//kinggamer ÿ≠ŸÇŸàŸÇ ÿßŸÑŸÅÿß ŸÉŸàÿØÿ≤ Ÿà
    if(!mention) return  message.channel.send('').then(msg => { //kinggamer ÿ≠ŸÇŸàŸÇ ÿßŸÑŸÅÿß ŸÉŸàÿØÿ≤ Ÿà
      msg.delete(3500);
      message.delete(3500);
    });
 
    if(mention.id === message.author.id) return message.channel.send('**:x:You Cannot give mute to your self**').then(msg => {
      msg.delete(3500);
      message.delete(3500); //kinggamer ÿ≠ŸÇŸàŸÇ ÿßŸÑŸÅÿß ŸÉŸàÿØÿ≤ Ÿà
    });
   
    if(mention.hasPermission('ADMINISTRATOR')) return message.channel.send(`**:x: ŸÑÿß ŸäŸÖŸÉŸÜ ÿ¢ÿπÿ∑ÿßÿ° ŸÖŸäŸàÿ™ ŸÑÿßÿØÿßÿ±ÿ© ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ±**`); //kinggamer ÿ≠ŸÇŸàŸÇ ÿßŸÑŸÅÿß ŸÉŸàÿØÿ≤ Ÿà
 
    if(message.guild.member(mention).roles.find('name', 'Muted')) return message.channel.send(`**:information_source: ${mention.user.username} Already Muted**`);
 
   
    if(mention.position >= message.guild.member(message.author).positon) return message.channel.send('You Dont Have Permission **Muted_Members** ').then(msg => {
      msg.delete(3500);
      message.delete(3500);
    });
   
    if(mention.positon >= message.guild.member(client.user).positon) return message.channel.send('I Dont Have Permission **Muted_Members**').then(msg => {
      msg.delete(3500);
      message.delete(3500); //kinggamer ÿ≠ŸÇŸàŸÇ ÿßŸÑŸÅÿß ŸÉŸàÿØÿ≤ Ÿà
    });
   
    let duration = args[2];
    if(!duration) message.channel.send(`**:hash: You Can Use ${prefix}mute @user Time Reason**`).then(msg => {
      msg.delete(3500);
      message.delete(3500);
    });
 
    if(isNaN(duration))  message.channel.send('').then(msg => {
      msg.delete(3500);
      message.delete(3500);
    });
 
    let reason = message.content.split(" ").slice(3).join(" ");
    if(!reason) reason = " [ **ŸÑŸÖ Ÿäÿ∞ŸÉÿ± ŸÑŸÖÿßÿ∞ÿß** ] ";
 
    let thisEmbed = new Discord.RichEmbed()
    .setAuthor(mention.user.username, mention.user.avatarURL)
    .setTitle('**ÿ™ŸÖ ÿ¢ÿπÿ∑ÿßÿ¶ŸÉ ŸÖŸäŸàÿ™**')
    .addField('**__ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ±__**',[ message.guild.name ]) //kinggamer ÿ≠ŸÇŸàŸÇ ÿßŸÑŸÅÿß ŸÉŸàÿØÿ≤ Ÿà
    .addField('**__ÿ™ŸÖ ÿ¢ÿπÿ∑ÿßÿ¶ŸÉ ŸÖŸäŸàÿ™ ÿ®Ÿàÿßÿ≥ÿ∑ÿ©__**', [ message.author ])
    .addField('**__ÿ¢ŸÑÿ≥ÿ®ÿ®__**',reason)
    .addField('**__ŸàŸÇÿ™ ÿßŸÑŸÖŸäŸàÿ™__**',duration)
 
    let role = message.guild.roles.find('name', 'Muted') || message.guild.roles.get(r => r.name === 'Muted');
    if(!role) try {
      message.guild.createRole({
        name: "Muted",
        permissions: 0 //kinggamer ÿ≠ŸÇŸàŸÇ ÿßŸÑŸÅÿß ŸÉŸàÿØÿ≤ Ÿà
      }).then(r => {
        message.guild.channels.forEach(c => {
          c.overwritePermissions(r , {
            SEND_MESSAGES: false, //kinggamer ÿ≠ŸÇŸàŸÇ ÿßŸÑŸÅÿß ŸÉŸàÿØÿ≤ Ÿà
            READ_MESSAGES_HISTORY: false,
            ADD_REACTIONS: false
          });
        });
      }); //kinggamer ÿ≠ŸÇŸàŸÇ ÿßŸÑŸÅÿß ŸÉŸàÿØÿ≤ Ÿà
    } catch(e) {
      console.log(e.stack);
    }
    mention.addRole(role).then(() => {
      mention.send(thisEmbed);
      message.channel.send(`**:white_check_mark: ${mention.user.username}  Muted! :zipper_mouth:  **  `);
      mention.setMute(true); //kinggamer ÿ≠ŸÇŸàŸÇ ÿßŸÑŸÅÿß ŸÉŸàÿØÿ≤ Ÿà
    });
    setTimeout(() => {
      if(duration === 0) return;
      mention.setMute(false);
      mention.removeRole(role)
    },duration * 60000); //kinggamer ÿ≠ŸÇŸàŸÇ ÿßŸÑŸÅÿß ŸÉŸàÿØÿ≤ Ÿà
  }
});
client.on('message', async message => {
    let mention = message.mentions.members.first();
let command = message.content.split(" ")[0];
     command = command.slice(prefix.length);
    let args = message.content.split(" ").slice(1);  //kinggamer ÿ≠ŸÇŸàŸÇ ÿßŸÑŸÅÿß ŸÉŸàÿØÿ≤ Ÿà
if(command === `unmute`) {2
  if(!message.member.hasPermission("MUTE_MEMBERS")) return message.channel.sendMessage("**You Donot HavePermission Mute_Members**").then(m => m.delete(5000));
if(!message.guild.member(client.user).hasPermission("MUTE_MEMBERS")) return message.reply("**I donot Have Permission Mute_Members**").then(msg => msg.delete(6000))
 
  let kinggamer = message.guild.member(message.mentions.users.first()) || message.guild.members.get(args[0]);
     if(!kinggamer) return message.channel.send('').then(msg => {
      msg.delete(3500);
      message.delete(3500); //kinggamer ÿ≠ŸÇŸàŸÇ ÿßŸÑŸÅÿß ŸÉŸàÿØÿ≤ Ÿà
    });
 
  let role = message.guild.roles.find (r => r.name === "Muted");
 
  if(!role || !kinggamer.roles.has(role.id)) return message.channel.sendMessage(`**:information_source:${mention.user.username} ŸÑŸÇÿØ ÿ™ŸÖ ŸÅŸÉ ÿßŸÑŸÖŸäŸàÿ™ ÿπŸÜŸá ŸÖÿ≥ÿ®ŸÇÿß**`)
 
  await kinggamer.removeRole(role) //kinggamer ÿ≠ŸÇŸàŸÇ ÿßŸÑŸÅÿß ŸÉŸàÿØÿ≤ Ÿà
  message.channel.sendMessage(`**:white_check_mark: ${mention.user.username}  Unmuted! **`);
 
  return;
 
  }
 
});




client.on('message', message => {
	var prefix = "S!";
if (message.content.startsWith(prefix + 'tag')) {
    let args = message.content.split(" ").slice(1);
if(!args[0]) return message.reply('ŸÖÿ±ÿ¨Ÿà ŸÉÿ™ÿßÿ®ÿ© ŸÜÿµ ÿßŸÑÿØŸä ÿ™ÿ±ŸäÿØ');  

    figlet(args.join(" "), (err, data) => {
              message.channel.send("```" + data + "```")
           })
}
});




client.on('message', message => {
  if (message.author.bot) return;
  if (!message.content.startsWith(prefix)) return;

  let command = message.content.split(" ")[0];
  command = command.slice(prefix.length);

  let args = message.content.split(" ").slice(1);
  
 

if (command == "z5rf") {
    let say = new Discord.RichEmbed()
    .setTitle('Text emboss :')

   message.reply(`\n ${zalgo(args.join(' '))}`);
  }

});


client.on('message', message =>{
  if(message.content.startsWith('S!join')){
    const voiceChannel = message.member.voiceChannel
    voiceChannel.join();
    message.channel.send("ÿ™ŸÖ ÿßŸÑÿ£ÿ™ÿµÿßŸÑ ÿ®ÿßŸÑÿ±ŸàŸÖ ÿßŸÑÿµŸàÿ™Ÿä")
}})




client.on('message', message => {
if(!message.channel.guild) return;
if(message.content.startsWith(prefix + 'move')) {
 if (message.member.hasPermission("MOVE_MEMBERS")) {
 if (message.mentions.users.size === 0) {
 return message.channel.send("``ŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿ£ŸÖÿ± ÿßŸÉÿ™ÿ® Ÿáÿ∞Ÿá ÿßŸÑÿ£ŸÖÿ± : " +prefix+ "move [USER]``")
}
if (message.member.voiceChannel != null) {
 if (message.mentions.members.first().voiceChannel != null) {
 var authorchannel = message.member.voiceChannelID;
 var usermentioned = message.mentions.members.first().id;
var embed = new Discord.RichEmbed()
 .setTitle("Succes!")
 .setColor("#000000")
 .setDescription(`ŸÑŸÇÿØ ŸÇŸÖÿ™ ÿ®ÿ≥ÿ≠ÿ® <@${usermentioned}> ÿßŸÑŸâ ÿßŸÑÿ±ŸàŸÖ ÿßŸÑÿµŸàÿ™Ÿä ÿßŸÑÿÆÿßÿµ ÿ®ŸÉ? `)
var embed = new Discord.RichEmbed()
.setTitle(`You are Moved in ${message.guild.name}`)
 .setColor("RANDOM")
.setDescription(`**<@${message.author.id}> Moved You To His Channel!**`)
 message.guild.members.get(usermentioned).setVoiceChannel(authorchannel).then(m => message.channel.send(embed))
message.guild.members.get(usermentioned).send(embed)
} else {
message.channel.send("``ŸÑÿß ÿ™ÿ≥ÿ™ÿ∑Ÿäÿπ ÿ≥ÿ≠ÿ® "+ message.mentions.members.first() +" `Ÿäÿ¨ÿ® ÿßŸÜ ŸäŸÉŸàŸÜ Ÿáÿ∞Ÿá ÿßŸÑÿπÿ∂Ÿà ŸÅŸä ÿ±ŸàŸÖ ÿµŸàÿ™Ÿä`")
}
} else {
 message.channel.send("**``Ÿäÿ¨ÿ® ÿßŸÜ ÿ™ŸÉŸàŸÜ ŸÅŸä ÿ±ŸàŸÖ ÿµŸàÿ™Ÿä ŸÑŸÉŸä ÿ™ŸÇŸàŸÖ ÿ®ÿ≥ÿ≠ÿ® ÿßŸÑÿπÿ∂Ÿà ÿ£ŸÑŸäŸÉ``**")
}
} else {
message.react("?")
 }}});




client.on('message' , message => {
      if(message.author.bot) return;
     
      if(message.content.startsWith(prefix + "rolebc")) {
        if (!message.member.hasPermission("ADMINISTRATOR"))  return;
        let args = message.content.split(" ").slice(2);
     var codes = args.join(' ')
       
        if(!codes) {
          message.channel.send("ŸÇŸÖ ÿ®ŸÉÿ™ÿßÿ®ÿ© ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© | S!rolebc @everyone message")
            return;
        }
     
     
              var role = message.mentions.roles.first();
                if(!role) {
                  message.reply("ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ±ÿ™ÿ®ÿ© ÿ®Ÿáÿ∞ÿß ÿßŸÑÿßÿ≥ŸÖ")
                    return;
                }
            message.guild.members.filter(m => m.roles.get(role.id)).forEach(n => {
              n.send(
              "**" + "ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ± :" + "\n" +
              `${message.guild.name}` + "\n" +
              "ÿßŸÑŸÖÿ±ÿ≥ŸÑ :" + "\n" +
              `${message.author.tag}` + "\n" +
              "ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© :" + "\n" +
              `${codes}` + "**"
              )
            })
            message.channel.send(`ŸÑŸÇÿØ ÿ™ŸÖ ÿßÿ±ÿ≥ÿßŸÑ Ÿáÿ∞Ÿá ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑŸâ ${message.guild.members.filter(m => m.roles.get(role.id)).size} ÿπÿ∂Ÿà`)
        }
    });



client.on('message', msg => {
  if (msg.author.bot) return;
  if (!msg.content.startsWith(prefix)) return;
  let command = msg.content.split(" ")[0];
  command = command.slice(prefix.length);
  let args = msg.content.split(" ").slice(1);

    if(command === "clear") {
        const emoji = client.emojis.find("name", "wastebasket")
    let textxt = args.slice(0).join("");
    if(msg.member.hasPermission("MANAGE_MESSAGES")) {
    if (textxt == "") {
        msg.delete().then
    msg.channel.send("***```ÿ∂ÿπ ÿπÿØÿØ ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑÿ™Ÿä ÿ™ÿ±ŸäÿØ ŸÖÿ≥ÿ≠Ÿáÿß ??```***").then(m => m.delete(3000));
} else {
    msg.delete().then
    msg.delete().then
    msg.channel.bulkDelete(textxt);
        msg.channel.send("```php\nÿπÿØÿØ ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑÿ™Ÿä ÿ™ŸÖ ŸÖÿ≥ÿ≠Ÿáÿß: " + textxt + "\n```").then(m => m.delete(3000));
        }    
    }
}
});





client.on('message',async message => {
    if(message.content.startsWith(prefix + "restart")) {
        if(message.author.id !== "459806154961453066") return message.reply('You aren\'t the bot owner.');
        message.channel.send('**Restarting.**').then(msg => {
            setTimeout(() => {
               msg.edit('**Restarting..**');
            },1000);
            setTimeout(() => {
               msg.edit('**Restarting...**');
            },2000);
        });
        console.log(`${message.author.tag} [ ${message.author.id} ] has restarted the bot.`);
        console.log(`Restart Done..`);
        setTimeout(() => {
            client.destroy();
client.login(process.env.BOT_TOKEN);
        },3000);
        }
});







client.on('message', message => {
     if (message.author.bot) return;
if (message.content.startsWith(prefix + "uptime")) {
    let uptime = client.uptime;

    let days = 0;
    let hours = 0;
    let minutes = 0;
    let seconds = 0;
    let notCompleted = true;

    while (notCompleted) {

        if (uptime >= 8.64e+7) {

            days++;
            uptime -= 8.64e+7;

        } else if (uptime >= 3.6e+6) {

            hours++;
            uptime -= 3.6e+6;

        } else if (uptime >= 60000) {

            minutes++;
            uptime -= 60000;

        } else if (uptime >= 1000) {
            seconds++;
            uptime -= 1000;

        }

        if (uptime < 1000)  notCompleted = false;

    }

    message.channel.send("`" + `${days} day, ${hours} hrs, ${minutes} min, ${seconds} sec` + "`");

}
});







client.on("message", msg => {
  if(msg.content === 'S!' + "id") {
      const embed = new Discord.RichEmbed();
  embed.addField("üî±| ÿßÿ≥ŸÖ ÿßŸÑÿ≠ÿ≥ÿßÿ® :", `${msg.author.username}#${msg.author.discriminator}`, true)
          .addField("üÜî| ÿßŸÑÿßŸä ÿØŸä :", `${msg.author.id}`, true)
          .setColor("RANDOM")
          .setFooter(msg.author.username , msg.author.avatarURL)
          .setThumbnail(`${msg.author.avatarURL}`)
          .setTimestamp()
          .setURL(`${msg.author.avatarURL}`)
          .addField('üìõ| ÿßŸÑÿ≠ÿßŸÑÿ© :', `${msg.author.presence.status.toUpperCase()}`, true)
          .addField('üé≤| ÿ®ŸÑÿßŸäŸÜÿ¨ :', `${msg.author.presence.game === null ? "No Game" : msg.author.presence.game.name}`, true)
          .addField('üèÖ| ÿßŸÑÿ±ÿ™ÿ® : ', `${msg.member.roles.filter(r => r.name).size}`, true)
          .addField('üìÖ| ÿ™ŸÖ ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ŸÑŸÑÿØŸäÿ≥ŸÉŸàÿ±ÿØ ŸÅŸä :', `${msg.createdAt}`,true)
          .addField('ü§ñ| ŸáŸÑ ŸáŸà ÿ®Ÿàÿ™ ÿü', `${msg.author.bot.toString().toUpperCase()}`, true);
      msg.channel.send({embed: embed})
  }
});


 
client.on('message', message => {
    var prefix = 'S!';
    if(message.content == prefix + 'count') {
        message.channel.send(`Members In This Server: **${message.guild.members.size}**`);
    }
});







client.on('ready', () => {
  console.log(`Logged in as ${client.user.tag}!`);
});

 client.on('message', message => {
              if(!message.channel.guild) return;
    var prefix = "S!";
    if(message.content.startsWith('S!bc')) {
    if(!message.channel.guild) return message.channel.send('**Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ± ŸÅŸÇÿ∑ ŸÑŸÑÿ≥Ÿäÿ±ŸÅÿ±ÿßÿ™**').then(m => m.delete(5000));
  if(!message.member.hasPermission('ADMINISTRATOR')) return      message.channel.send('**ŸÑŸÑÿ£ÿ≥ŸÅ ŸÑÿß ÿ™ŸÖÿ™ŸÑŸÉ ÿµŸÑÿßÿ≠Ÿäÿ©** `ADMINISTRATOR`' );
    let args = message.content.split(" ").join(" ").slice(2 + prefix.length);
    let copy = "${message.guild.name}";
    let request = `Requested By ${message.author.username}`;
    if (!args) return message.reply('**Ÿäÿ¨ÿ® ÿπŸÑŸäŸÉ ŸÉÿ™ÿßÿ®ÿ© ŸÉŸÑŸÖÿ© ÿßŸà ÿ¨ŸÖŸÑÿ© ŸÑÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ®ÿ±ŸàÿØŸÉÿßÿ≥ÿ™**');message.channel.send(`**ŸáŸÑ ÿ£ŸÜÿ™ ŸÖÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ•ÿ±ÿ≥ÿßŸÑŸÉ ÿßŸÑÿ®ÿ±ŸàÿØŸÉÿßÿ≥ÿ™ÿü \nŸÖÿ≠ÿ™ŸàŸâ ÿßŸÑÿ®ÿ±ŸàÿØŸÉÿßÿ≥ÿ™:** \` ${args}\``).then(msg => {
    msg.react('‚úÖ')
    .then(() => msg.react('‚ùå'))
    .then(() =>msg.react('‚úÖ'))

    let reaction1Filter = (reaction, user) => reaction.emoji.name === '‚úÖ' && user.id === message.author.id;
    let reaction2Filter = (reaction, user) => reaction.emoji.name === '‚ùå' && user.id === message.author.id;
       let reaction1 = msg.createReactionCollector(reaction1Filter, { time: 12000 });
    let reaction2 = msg.createReactionCollector(reaction2Filter, { time: 12000 });
    reaction1.on("collect", r => {
    message.channel.send(`‚òë | Done ... The Broadcast Message Has Been Sent For ${message.guild.members.size} Members`).then(m => m.delete(5000));
    message.guild.members.forEach(m => {
    var bc = new
       Discord.RichEmbed()
       .setColor('RANDOM')
       .setTitle('Broadcast | ÿ®ÿ±ŸàÿØŸÉÿßÿ≥ÿ™')
       .addField('Server | ÿ≥Ÿäÿ±ŸÅÿ±', message.guild.name)
       .addField('Sender | ÿßŸÑŸÖÿ±ÿ≥ŸÑ', message.author.username)
       .addField('Message | ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©', args)
       .setFooter(copy, client.user.avatarURL);
    m.send({ embed: bc })
    msg.delete();
    })
    })
    reaction2.on("collect", r => {
    message.channel.send(`**Broadcast Canceled.**`).then(m => m.delete(5000));
    msg.delete();
    })
    })
    }
    });



    






client.on('message', message => {
              if (!message.channel.guild) return;
      if(message.content =='S!members')
      var kayan = new Discord.RichEmbed()
      .setThumbnail(message.author.avatarURL)
      .setFooter(message.author.username, message.author.avatarURL) 
      .setTitle('üå∑| Members info')
      .addBlankField(true)
      .addField('üìó| Online',
      `${message.guild.members.filter(m=>m.presence.status == 'online').size}`)
      .addField('üìï| DND',`${message.guild.members.filter(m=>m.presence.status == 'dnd').size}`)
      .addField('üìô| Idle',`${message.guild.members.filter(m=>m.presence.status == 'idle').size}`)
      .addField('üìì| Offline',`${message.guild.members.filter(m=>m.presence.status == 'offline').size}`)
      .addField('‚û°| Server Members',`${message.guild.memberCount}`)
      message.channel.send(kayan);
    
    });





client.on('message', async msg => {
     client.snek = require('snekfetch');
    var p = "S!"
  if(msg.content.startsWith(p + "draw")) {
   let args = msg.content.split(' ').slice(1).join(' ');

 if(args.length < 1) return args.missing(msg, 'No text added', this.help);
  msg.channel.startTyping();
  const searchMessage = await msg.channel.send('üñåÔ∏èPainting...');
  const { body } = await client.snek.get(`https://nekobot.xyz/api/imagegen?type=changemymind&text=${encodeURIComponent(args)}`);
  msg.channel.send({file: { attachment:body.message, name: 'changemymind.png'}}).then(()=> { searchMessage.delete(); msg.channel.stopTyping(); });
};
});





client.on('message', message =>{
    if(message.content === 'S!ping'){
let start = Date.now(); message.channel.send('pong').then(message => { 
message.edit(`\`\`\`js
Time taken: ${Date.now() - start} ms
Discord API: ${client.ping.toFixed(0)} ms\`\`\``);
    });
    }
});



client.on('message',async message => {
  let args = message.content.split(" ").slice(1).join(" ");
  let role = message.guild.roles.find('name',args) || message.guild.roles.get(args);
 
 
  if(message.content.startsWith(prefix + "roleinfo")) {
    if(!args) return message.reply('ÿßŸÉÿ™ÿ® ÿßÿ≥ŸÖ ÿßŸÑÿ±ÿ™ÿ®ÿ©');
    if(!role) return message.reply('Ÿáÿ∞Ÿá ÿßŸÑÿ±ÿ™ÿ®ÿ© ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØÿ©');
    let iQp = new Discord.RichEmbed()
    .setAuthor(message.author.tag,message.author.avatarURL)
    .setTitle(message.guild.name)
    .setThumbnail(message.guild.iconURL)
    .addField('- ÿßÿ≥ŸÖ ÿßŸÑÿ±ÿ™ÿ®ÿ©',role.name,true)
    .addField('- ÿßŸä ÿØŸä ÿßŸÑÿ±ÿ™ÿ®ÿ©',role.id,true)
    .addField('- ÿ™ŸÖ ÿßŸÜÿ¥ÿßÿ° ÿßŸÑÿ±ÿ™ÿ®ÿ©',role.createdAt.toLocaleString(),true)
    .addField('- ŸÑŸàŸÜ ÿßŸÑÿ±ÿ™ÿ®ÿ©',role.hexColor,true)
    .addField('- ÿπÿØÿØ ÿßŸÑÿßÿπÿ∂ÿßÿ° ÿßŸÑÿ∞Ÿä ŸÑÿØŸäŸáŸÖ ŸÜŸÅÿ≥ ÿßŸÑÿ±ÿ™ÿ®ÿ©',role.members.size,true)
    .addField('- ŸÖÿ±ŸÉÿ≤ ÿßŸÑÿ±ÿ™ÿ®ÿ© ÿ®ŸäŸÜ ŸÉŸÑ ÿßŸÑÿ±ÿ™ÿ®',role.position,true)
    .addField('- ÿÆÿµÿßÿ¶ÿµ ÿßŸÑÿ±ÿ™ÿ®ÿ©',role.permissions,true)
    .setFooter(message.author.tag,message.author.avatarURL);
 
    message.channel.send(iQp);
  }
});


client.on('ready', () => {setInterval(function(){ client.guilds.get("493862684693889024").roles.find("name", 'rainbow').edit({color : "RANDOM"})},1000)})


client.on('messageDelete', message => {
 
    if(message.author.bot) return;
    if(message.channel.type === 'dm') return;
    if(!message.guild.member(client.user).hasPermission('EMBED_LINKS')) return;
    if(!message.guild.member(client.user).hasPermission('MANAGE_MESSAGES')) return;
 
    var logChannel = message.guild.channels.find(c => c.name === 'log');
    if(!logChannel) return;
 
    let messageDelete = new Discord.RichEmbed()
    .setTitle('**[MESSAGE DELETE]**')
    .setColor('RED')
    .setThumbnail(message.author.avatarURL)
    .setDescription(`**\n**:wastebasket: Successfully \`\`DELETE\`\` **MESSAGE** In ${message.channel}\n\n**Channel:** \`\`${message.channel.name}\`\` (ID: ${message.channel.id})\n**Message ID:** ${message.id}\n**Sent By:** <@${message.author.id}> (ID: ${message.author.id})\n**Message:**\n\`\`\`${message}\`\`\``)
    .setTimestamp()
    .setFooter(message.guild.name, message.guild.iconURL)
 
    logChannel.send(messageDelete);
});
client.on('messageUpdate', (oldMessage, newMessage) => {
 
    if(oldMessage.author.bot) return;
    if(!oldMessage.channel.type === 'dm') return;
    if(!oldMessage.guild.member(client.user).hasPermission('EMBED_LINKS')) return;
    if(!oldMessage.guild.member(client.user).hasPermission('MANAGE_MESSAGES')) return;
 
    var logChannel = oldMessage.guild.channels.find(c => c.name === 'log');
    if(!logChannel) return;
 
    if(oldMessage.content.startsWith('https://')) return;
 
    let messageUpdate = new Discord.RichEmbed()
    .setTitle('**[MESSAGE EDIT]**')
    .setThumbnail(oldMessage.author.avatarURL)
    .setColor('BLUE')
    .setDescription(`**\n**:wrench: Successfully \`\`EDIT\`\` **MESSAGE** In ${oldMessage.channel}\n\n**Channel:** \`\`${oldMessage.channel.name}\`\` (ID: ${oldMessage.channel.id})\n**Message ID:** ${oldMessage.id}\n**Sent By:** <@${oldMessage.author.id}> (ID: ${oldMessage.author.id})\n\n**Old Message:**\`\`\`${oldMessage}\`\`\`\n**New Message:**\`\`\`${newMessage}\`\`\``)
    .setTimestamp()
    .setFooter(oldMessage.guild.name, oldMessage.guild.iconURL)
 
    logChannel.send(messageUpdate);
});
 
 
client.on('roleCreate', role => {
 
    if(!role.guild.member(client.user).hasPermission('EMBED_LINKS')) return;
    if(!role.guild.member(client.user).hasPermission('VIEW_AUDIT_LOG')) return;
 
    var logChannel = role.guild.channels.find(c => c.name === 'log');
    if(!logChannel) return;
 
    role.guild.fetchAuditLogs().then(logs => {
        var userID = logs.entries.first().executor.id;
        var userAvatar = logs.entries.first().executor.avatarURL;
 
        let roleCreate = new Discord.RichEmbed()
        .setTitle('**[ROLE CREATE]**')
        .setThumbnail(userAvatar)
        .setDescription(`**\n**:white_check_mark: Successfully \`\`CREATE\`\` Role.\n\n**Role Name:** \`\`${role.name}\`\` (ID: ${role.id})\n**By:** <@${userID}> (ID: ${userID})`)
        .setColor('GREEN')
        .setTimestamp()
        .setFooter(role.guild.name, role.guild.iconURL)
 
        logChannel.send(roleCreate);
    })
});
client.on('roleDelete', role => {
 
    if(!role.guild.member(client.user).hasPermission('EMBED_LINKS')) return;
    if(!role.guild.member(client.user).hasPermission('VIEW_AUDIT_LOG')) return;
 
    var logChannel = role.guild.channels.find(c => c.name === 'log');
    if(!logChannel) return;
 
    role.guild.fetchAuditLogs().then(logs => {
        var userID = logs.entries.first().executor.id;
        var userAvatar = logs.entries.first().executor.avatarURL;
 
        let roleDelete = new Discord.RichEmbed()
        .setTitle('**[ROLE DELETE]**')
        .setThumbnail(userAvatar)
        .setDescription(`**\n**:white_check_mark: Successfully \`\`DELETE\`\` Role.\n\n**Role Name:** \`\`${role.name}\`\` (ID: ${role.id})\n**By:** <@${userID}> (ID: ${userID})`)
        .setColor('RED')
        .setTimestamp()
        .setFooter(role.guild.name, role.guild.iconURL)
 
        logChannel.send(roleDelete);
    })
});
client.on('roleUpdate', (oldRole, newRole) => {
 
    if(!oldRole.guild.member(client.user).hasPermission('EMBED_LINKS')) return;
    if(!oldRole.guild.member(client.user).hasPermission('VIEW_AUDIT_LOG')) return;
 
    var logChannel = oldRole.guild.channels.find(c => c.name === 'log');
    if(!logChannel) return;
 
    oldRole.guild.fetchAuditLogs().then(logs => {
        var userID = logs.entries.first().executor.id;
        var userAvatar = logs.entries.first().executor.avatarURL;
 
        if(oldRole.name !== newRole.name) {
            let roleUpdateName = new Discord.RichEmbed()
            .setTitle('**[ROLE NAME UPDATE]**')
            .setThumbnail(userAvatar)
            .setColor('BLUE')
            .setDescription(`**\n**:white_check_mark: Successfully \`\`EDITED\`\` Role Name.\n\n**Old Name:** \`\`${oldRole.name}\`\`\n**New Name:** \`\`${newRole.name}\`\`\n**Role ID:** ${oldRole.id}\n**By:** <@${userID}> (ID: ${userID})`)
            .setTimestamp()
            .setFooter(oldRole.guild.name, oldRole.guild.iconURL)
 
            logChannel.send(roleUpdateName);
        }
    })
});
 
 
client.on('channelCreate', channel => {
 
    if(!channel.guild) return;
    if(!channel.guild.member(client.user).hasPermission('EMBED_LINKS')) return;
    if(!channel.guild.member(client.user).hasPermission('VIEW_AUDIT_LOG')) return;
 
    var logChannel = channel.guild.channels.find(c => c.name === 'log');
    if(!logChannel) return;
 
    if(channel.type === 'text') {
        var roomType = 'Text';
    }else
    if(channel.type === 'voice') {
        var roomType = 'Voice';
    }else
    if(channel.type === 'category') {
        var roomType = 'Category';
    }
 
    channel.guild.fetchAuditLogs().then(logs => {
        var userID = logs.entries.first().executor.id;
        var userAvatar = logs.entries.first().executor.avatarURL;
 
        let channelCreate = new Discord.RichEmbed()
        .setTitle('**[CHANNEL CREATE]**')
        .setThumbnail(userAvatar)
        .setDescription(`**\n**:white_check_mark: Successfully \`\`CREATE\`\` **${roomType}** channel.\n\n**Channel Name:** \`\`${channel.name}\`\` (ID: ${channel.id})\n**By:** <@${userID}> (ID: ${userID})`)
        .setColor('GREEN')
        .setTimestamp()
        .setFooter(channel.guild.name, channel.guild.iconURL)
 
        logChannel.send(channelCreate);
    })
});
client.on('channelDelete', channel => {
    if(!channel.guild) return;
    if(!channel.guild.member(client.user).hasPermission('EMBED_LINKS')) return;
    if(!channel.guild.member(client.user).hasPermission('VIEW_AUDIT_LOG')) return;
 
    var logChannel = channel.guild.channels.find(c => c.name === 'log');
    if(!logChannel) return;
 
    if(channel.type === 'text') {
        var roomType = 'Text';
    }else
    if(channel.type === 'voice') {
        var roomType = 'Voice';
    }else
    if(channel.type === 'category') {
        var roomType = 'Category';
    }
 
    channel.guild.fetchAuditLogs().then(logs => {
        var userID = logs.entries.first().executor.id;
        var userAvatar = logs.entries.first().executor.avatarURL;
 
        let channelDelete = new Discord.RichEmbed()
        .setTitle('**[CHANNEL DELETE]**')
        .setThumbnail(userAvatar)
        .setDescription(`**\n**:white_check_mark: Successfully \`\`DELETE\`\` **${roomType}** channel.\n\n**Channel Name:** \`\`${channel.name}\`\` (ID: ${channel.id})\n**By:** <@${userID}> (ID: ${userID})`)
        .setColor('RED')
        .setTimestamp()
        .setFooter(channel.guild.name, channel.guild.iconURL)
 
        logChannel.send(channelDelete);
    })
});
client.on('channelUpdate', (oldChannel, newChannel) => {
    if(!oldChannel.guild) return;
 
    var logChannel = oldChannel.guild.channels.find(c => c.name === 'log');
    if(!logChannel) return;
 
    if(oldChannel.type === 'text') {
        var channelType = 'Text';
    }else
    if(oldChannel.type === 'voice') {
        var channelType = 'Voice';
    }else
    if(oldChannel.type === 'category') {
        var channelType = 'Category';
    }
 
    oldChannel.guild.fetchAuditLogs().then(logs => {
        var userID = logs.entries.first().executor.id;
        var userAvatar = logs.entries.first().executor.avatarURL;
 
        if(oldChannel.name !== newChannel.name) {
            let newName = new Discord.RichEmbed()
            .setTitle('**[CHANNEL EDIT]**')
            .setThumbnail(userAvatar)
            .setColor('BLUE')
            .setDescription(`**\n**:wrench: Successfully Edited **${channelType}** Channel Name\n\n**Old Name:** \`\`${oldChannel.name}\`\`\n**New Name:** \`\`${newChannel.name}\`\`\n**Channel ID:** ${oldChannel.id}\n**By:** <@${userID}> (ID: ${userID})`)
            .setTimestamp()
            .setFooter(oldChannel.guild.name, oldChannel.guild.iconURL)
 
            logChannel.send(newName);
        }
        if(oldChannel.topic !== newChannel.topic) {
            let newTopic = new Discord.RichEmbed()
            .setTitle('**[CHANNEL EDIT]**')
            .setThumbnail(userAvatar)
            .setColor('BLUE')
            .setDescription(`**\n**:wrench: Successfully Edited **${channelType}** Channel Topic\n\n**Old Topic:**\n\`\`\`${oldChannel.topic || 'NULL'}\`\`\`\n**New Topic:**\n\`\`\`${newChannel.topic || 'NULL'}\`\`\`\n**Channel:** ${oldChannel} (ID: ${oldChannel.id})\n**By:** <@${userID}> (ID: ${userID})`)
            .setTimestamp()
            .setFooter(oldChannel.guild.name, oldChannel.guild.iconURL)
 
            logChannel.send(newTopic);
        }
    })
});
 
 
client.on('guildBanAdd', (guild, user) => {
 
    if(!guild.member(client.user).hasPermission('EMBED_LINKS')) return;
    if(!guild.member(client.user).hasPermission('VIEW_AUDIT_LOG')) return;
 
    var logChannel = guild.channels.find(c => c.name === 'log');
    if(!logChannel) return;
 
    guild.fetchAuditLogs().then(logs => {
        var userID = logs.entries.first().executor.id;
        var userAvatar = logs.entries.first().executor.avatarURL;
 
        if(userID === client.user.id) return;
 
        let banInfo = new Discord.RichEmbed()
        .setTitle('**[BANNED]**')
        .setThumbnail(userAvatar)
        .setColor('DARK_RED')
        .setDescription(`**\n**:airplane: Successfully \`\`BANNED\`\` **${user.username}** From the server!\n\n**User:** <@${user.id}> (ID: ${user.id})\n**By:** <@${userID}> (ID: ${userID})`)
        .setTimestamp()
        .setFooter(guild.name, guild.iconURL)
 
        logChannel.send(banInfo);
    })
});
client.on('guildBanRemove', (guild, user) => {
    if(!guild.member(client.user).hasPermission('EMBED_LINKS')) return;
    if(!guild.member(client.user).hasPermission('VIEW_AUDIT_LOG')) return;
 
    var logChannel = guild.channels.find(c => c.name === 'log');
    if(!logChannel) return;
 
    guild.fetchAuditLogs().then(logs => {
        var userID = logs.entries.first().executor.id;
        var userAvatar = logs.entries.first().executor.avatarURL;
 
        if(userID === client.user.id) return;
 
        let unBanInfo = new Discord.RichEmbed()
        .setTitle('**[UNBANNED]**')
        .setThumbnail(userAvatar)
        .setColor('GREEN')
        .setDescription(`**\n**:unlock: Successfully \`\`UNBANNED\`\` **${user.username}** From the server\n\n**User:** <@${user.id}> (ID: ${user.id})\n**By:** <@${userID}> (ID: ${userID})`)
        .setTimestamp()
        .setFooter(guild.name, guild.iconURL)
 
        logChannel.send(unBanInfo);
    })
});
client.on('guildUpdate', (oldGuild, newGuild) => {
 
    if(!oldGuild.member(client.user).hasPermission('EMBED_LINKS')) return;
    if(!oldGuild.member(client.user).hasPermission('VIEW_AUDIT_LOG')) return;
 
    var logChannel = oldGuild.channels.find(c => c.name === 'log');
    if(!logChannel) return;
 
    oldGuild.fetchAuditLogs().then(logs => {
        var userID = logs.entries.first().executor.id;
        var userAvatar = logs.entries.first().executor.avatarURL;
 
        if(oldGuild.name !== newGuild.name) {
            let guildName = new Discord.RichEmbed()
            .setTitle('**[CHANGE GUILD NAME]**')
            .setThumbnail(userAvatar)
            .setColor('BLUE')
            .setDescription(`**\n**:white_check_mark: Successfully \`\`EDITED\`\` The guild name.\n\n**Old Name:** \`\`${oldGuild.name}\`\`\n**New Name:** \`\`${newGuild.name}\`\`\n**By:** <@${userID}> (ID: ${userID})`)
            .setTimestamp()
            .setFooter(newGuild.name, oldGuild.iconURL)
 
            logChannel.send(guildName)
        }
        if(oldGuild.region !== newGuild.region) {
            let guildRegion = new Discord.RichEmbed()
            .setTitle('**[CHANGE GUILD REGION]**')
            .setThumbnail(userAvatar)
            .setColor('BLUE')
            .setDescription(`**\n**:white_check_mark: Successfully \`\`EDITED\`\` The guild region.\n\n**Old Region:** ${oldGuild.region}\n**New Region:** ${newGuild.region}\n**By:** <@${userID}> (ID: ${userID})`)
            .setTimestamp()
            .setFooter(oldGuild.name, oldGuild.iconURL)
 
            logChannel.send(guildRegion);
        }
        if(oldGuild.verificationLevel !== newGuild.verificationLevel) {
            if(oldGuild.verificationLevel === 0) {
                var oldVerLvl = 'Very Easy';
            }else
            if(oldGuild.verificationLevel === 1) {
                var oldVerLvl = 'Easy';
            }else
            if(oldGuild.verificationLevel === 2) {
                var oldVerLvl = 'Medium';
            }else
            if(oldGuild.verificationLevel === 3) {
                var oldVerLvl = 'Hard';
            }else
            if(oldGuild.verificationLevel === 4) {
                var oldVerLvl = 'Very Hard';
            }
 
            if(newGuild.verificationLevel === 0) {
                var newVerLvl = 'Very Easy';
            }else
            if(newGuild.verificationLevel === 1) {
                var newVerLvl = 'Easy';
            }else
            if(newGuild.verificationLevel === 2) {
                var newVerLvl = 'Medium';
            }else
            if(newGuild.verificationLevel === 3) {
                var newVerLvl = 'Hard';
            }else
            if(newGuild.verificationLevel === 4) {
                var newVerLvl = 'Very Hard';
            }
 
            let verLog = new Discord.RichEmbed()
            .setTitle('**[GUILD VERIFICATION LEVEL CHANGE]**')
            .setThumbnail(userAvatar)
            .setColor('BLUE')
            .setDescription(`**\n**:white_check_mark: Successfully \`\`EDITED\`\` Guild Verification level.\n\n**Old Verification Level:** ${oldVerLvl}\n**New Verification Level:** ${newVerLvl}\n**By:** <@${userID}> (ID: ${userID})`)
            .setTimestamp()
            .setFooter(oldGuild.name, oldGuild.iconURL)
 
            logChannel.send(verLog);
        }
    })
});
client.on('guildMemberUpdate', (oldMember, newMember) => {
    if(!oldMember.guild) return;
 
    var logChannel = oldMember.guild.channels.find(c => c.name === 'log');
    if(!logChannel) return;
 
    oldMember.guild.fetchAuditLogs().then(logs => {
        var userID = logs.entries.first().executor.id;
        var userAvatar = logs.entries.first().executor.avatarURL;
        var userTag = logs.entries.first().executor.tag;
 
        if(oldMember.nickname !== newMember.nickname) {
            if(oldMember.nickname === null) {
                var oldNM = '`ÿßÿ≥ŸÖŸá ÿßŸÑÿßÿµŸÑŸä`';
            }else {
                var oldNM = oldMember.nickname;
            }
            if(newMember.nickname === null) {
                var newNM = '`ÿßÿ≥ŸÖŸá ÿßŸÑÿßÿµŸÑŸä`';
            }else {
                var newNM = newMember.nickname;
            }
 
            let updateNickname = new Discord.RichEmbed()
            .setTitle('**[UPDATE MEMBER NICKNAME]**')
            .setThumbnail(userAvatar)
            .setColor('BLUE')
            .setDescription(`**\n**:spy: Successfully \`\`CHANGE\`\` Member Nickname.\n\n**User:** ${oldMember} (ID: ${oldMember.id})\n**Old Nickname:** ${oldNM}\n**New Nickname:** ${newNM}\n**By:** <@${userID}> (ID: ${userID})`)
            .setTimestamp()
            .setFooter(oldMember.guild.name, oldMember.guild.iconURL)
 
            logChannel.send(updateNickname);
        }
        if(oldMember.roles.size < newMember.roles.size) {
            let role = newMember.roles.filter(r => !oldMember.roles.has(r.id)).first();
 
            let roleAdded = new Discord.RichEmbed()
            .setTitle('**[ADDED ROLE TO MEMBER]**')
            .setThumbnail(oldMember.guild.iconURL)
            .setColor('GREEN')
            .setDescription(`**\n**:white_check_mark: Successfully \`\`ADDED\`\` Role to **${oldMember.user.username}**\n\n**User:** <@${oldMember.id}> (ID: ${oldMember.user.id})\n**Role:** \`\`${role.name}\`\` (ID: ${role.id})\n**By:** <@${userID}> (ID: ${userID})`)
            .setTimestamp()
            .setFooter(userTag, userAvatar)
 
            logChannel.send(roleAdded);
        }
        if(oldMember.roles.size > newMember.roles.size) {
            let role = oldMember.roles.filter(r => !newMember.roles.has(r.id)).first();
 
            let roleRemoved = new Discord.RichEmbed()
            .setTitle('**[REMOVED ROLE FROM MEMBER]**')
            .setThumbnail(oldMember.guild.iconURL)
            .setColor('RED')
            .setDescription(`**\n**:negative_squared_cross_mark: Successfully \`\`REMOVED\`\` Role from **${oldMember.user.username}**\n\n**User:** <@${oldMember.user.id}> (ID: ${oldMember.id})\n**Role:** \`\`${role.name}\`\` (ID: ${role.id})\n**By:** <@${userID}> (ID: ${userID})`)
            .setTimestamp()
            .setFooter(userTag, userAvatar)
 
            logChannel.send(roleRemoved);
        }
    })
    if(oldMember.guild.owner.id !== newMember.guild.owner.id) {
        let newOwner = new Discord.RichEmbed()
        .setTitle('**[UPDATE GUILD OWNER]**')
        .setThumbnail(oldMember.guild.iconURL)
        .setColor('GREEN')
        .setDescription(`**\n**:white_check_mark: Successfully \`\`TRANSFER\`\` The Owner Ship.\n\n**Old Owner:** <@${oldMember.user.id}> (ID: ${oldMember.user.id})\n**New Owner:** <@${newMember.user.id}> (ID: ${newMember.user.id})`)
        .setTimestamp()
        .setFooter(oldMember.guild.name, oldMember.guild.iconURL)
 
        logChannel.send(newOwner);
    }
});
 
 
client.on('voiceStateUpdate', (voiceOld, voiceNew) => {
 
    if(!voiceOld.guild.member(client.user).hasPermission('EMBED_LINKS')) return;
    if(!voiceOld.guild.member(client.user).hasPermission('VIEW_AUDIT_LOG')) return;
 
    var logChannel = voiceOld.guild.channels.find(c => c.name === 'log');
    if(!logChannel) return;
 
    voiceOld.guild.fetchAuditLogs().then(logs => {
        var userID = logs.entries.first().executor.id;
        var userTag = logs.entries.first().executor.tag;
        var userAvatar = logs.entries.first().executor.avatarURL;
 
        if(voiceOld.serverMute === false && voiceNew.serverMute === true) {
            let serverMutev = new Discord.RichEmbed()
            .setTitle('**[VOICE MUTE]**')
            .setThumbnail('https://images-ext-1.discordapp.net/external/pWQaw076OHwVIFZyeFoLXvweo0T_fDz6U5C9RBlw_fQ/https/cdn.pg.sa/UosmjqDNgS.png')
            .setColor('RED')
            .setDescription(`**User:** ${voiceOld} (ID: ${voiceOld.id})\n**By:** <@${userID}> (ID: ${userID})\n**Channel:** \`\`${voiceOld.voiceChannel.name}\`\` (ID: ${voiceOld.voiceChannel.id})`)
            .setTimestamp()
            .setFooter(userTag, userAvatar)
 
            logChannel.send(serverMutev);
        }
        if(voiceOld.serverMute === true && voiceNew.serverMute === false) {
            let serverUnmutev = new Discord.RichEmbed()
            .setTitle('**[VOICE UNMUTE]**')
            .setThumbnail('https://images-ext-1.discordapp.net/external/u2JNOTOc1IVJGEb1uCKRdQHXIj5-r8aHa3tSap6SjqM/https/cdn.pg.sa/Iy4t8H4T7n.png')
            .setColor('GREEN')
            .setDescription(`**User:** ${voiceOld} (ID: ${voiceOld.id})\n**By:** <@${userID}> (ID: ${userID})\n**Channel:** \`\`${voiceOld.voiceChannel.name}\`\` (ID: ${voiceOld.voiceChannel.id})`)
            .setTimestamp()
            .setFooter(userTag, userAvatar)
 
            logChannel.send(serverUnmutev);
        }
        if(voiceOld.serverDeaf === false && voiceNew.serverDeaf === true) {
            let serverDeafv = new Discord.RichEmbed()
            .setTitle('**[VOICE DEAF]**')
            .setThumbnail('https://images-ext-1.discordapp.net/external/7ENt2ldbD-3L3wRoDBhKHb9FfImkjFxYR6DbLYRjhjA/https/cdn.pg.sa/auWd5b95AV.png')
            .setColor('RED')
            .setDescription(`**User:** ${voiceOld} (ID: ${voiceOld.id})\n**By:** <@${userID}> (ID: ${userID})\n**Channel:** \`\`${voiceOld.voiceChannel.name}\`\` (ID: ${voiceOld.voiceChannel.id})`)
            .setTimestamp()
            .setFooter(userTag, userAvatar)
 
            logChannel.send(serverDeafv);
        }
        if(voiceOld.serverDeaf === true && voiceNew.serverDeaf === false) {
            let serverUndeafv = new Discord.RichEmbed()
            .setTitle('**[VOICE UNDEAF]**')
            .setThumbnail('https://images-ext-2.discordapp.net/external/s_abcfAlNdxl3uYVXnA2evSKBTpU6Ou3oimkejx3fiQ/https/cdn.pg.sa/i7fC8qnbRF.png')
            .setColor('GREEN')
            .setDescription(`**User:** ${voiceOld} (ID: ${voiceOld.id})\n**By:** <@${userID}> (ID: ${userID})\n**Channel:** \`\`${voiceOld.voiceChannel.name}\`\` (ID: ${voiceOld.voiceChannel.id})`)
            .setTimestamp()
            .setFooter(userTag, userAvatar)
 
            logChannel.send(serverUndeafv);
        }
    })
});



client.on('message', message => {
  if(message.content === 'S!support') {
  const embed = new Discord.RichEmbed()
  .setTitle('Click here')
  .setURL('https://discord.gg/wQWzHwM')
  .setColor('RANDOM')
  message.channel.send({embed: embed});
  }
});


client.on('message', message => {
  if (true) {
if (message.content === 'S!invite') {
      message.author.send('  https://discordapp.com/oauth2/authorize?client_id=487211103819137036&scope=bot&permissions=8  |  ÿ™ŸÅÿ∂ŸÑ ÿ±ÿßÿ®ÿ∑ ÿßŸÑÿ®Ÿàÿ™     ').catch(e => console.log(e.stack));
 
    }
   }
  });
 
 
client.on('message', message => {
     if (message.content === "S!invite") {
     let embed = new Discord.RichEmbed()
  .setAuthor(message.author.username)
  .setColor("#9B59B6")
  .addField(" Done | ÿ™ŸÄŸÄŸÄŸÄŸÖ" , " |  ÿ™ŸÄŸÄŸÄŸÄŸÖ ÿßÿ±ÿ≥ŸÄŸÄÿßŸÑŸÉ ŸÅŸä ÿßŸÑÿÆŸÄŸÄÿßÿµ")
     
     
     
  message.channel.sendEmbed(embed);
    }
});




const db = require('quick.db');   
const giphy = require('giphy-api')();    
const googl = require('goo.gl');  
const getYoutubeID = require('get-youtube-id'); 
const { Client, Util } = require('discord.js');  
const UserBlocked = new Set(); 
const stripIndents = require('common-tags').stripIndents;
const figlet = require('figlet');
const google = require('google-it'); 
const queue = new Map(); 
const zalgo = require('zalgolize');   
const fetchVideoInfo = require('youtube-info');
const YouTube = require('simple-youtube-api');
const ytdl = require('ytdl-core');
const youtube = new YouTube("AIzaSyAdORXg7UZUo7sePv97JyoDqtQVi3Ll0b8");
const sql = require("sqlite");
 const dateFormat = require('dateformat'); 
 const pretty = require('pretty-ms') 


client.on('message', async msg => { 
	if (msg.author.bot) return undefined;
	if (!msg.content.startsWith(prefix)) return undefined;
	const args = msg.content.split(' ');
	const searchString = args.slice(1).join(' ');
	const url = args[1] ? args[1].replace(/<(.+)>/g, '$1') : '';
	const serverQueue = queue.get(msg.guild.id);
	let command = msg.content.toLowerCase().split(" ")[0];
	command = command.slice(prefix.length)
	if (command === `play`) {
		const voiceChannel = msg.member.voiceChannel;
		if (!voiceChannel) return msg.channel.send('Ÿäÿ¨ÿ® ÿ™Ÿàÿ¢ÿ¨ÿØ ÿ≠ÿ∂ÿ±ÿ™ŸÉ ÿ®ÿ±ŸàŸÖ ÿµŸàÿ™Ÿä .');
		const permissions = voiceChannel.permissionsFor(msg.client.user);
		if (!permissions.has('CONNECT')) {
			
			return msg.channel.send('ŸÑÿß Ÿäÿ™Ÿàÿ¢ÿ¨ÿØ ŸÑÿØŸä ÿµŸÑÿßÿ≠Ÿäÿ© ŸÑŸÑÿ™ŸÉŸÑŸÖ ÿ®Ÿáÿ∞ÿ¢ ÿßŸÑÿ±ŸàŸÖ');
		}
		if (!permissions.has('SPEAK')) {
			return msg.channel.send('ŸÑÿß Ÿäÿ™Ÿàÿ¢ÿ¨ÿØ ŸÑÿØŸä ÿµŸÑÿßÿ≠Ÿäÿ© ŸÑŸÑÿ™ŸÉŸÑŸÖ ÿ®Ÿáÿ∞ÿ¢ ÿßŸÑÿ±ŸàŸÖ');
		}

		if (!permissions.has('EMBED_LINKS')) {
			return msg.channel.sendMessage("**Ÿäÿ¨ÿ® ÿ™Ÿàÿ¢ŸÅÿ± ÿ®ÿ±ŸÖÿ¥ŸÜ `EMBED LINKS`ŸÑÿØŸä **")
		}

		if (url.match(/^https?:\/\/(www.youtube.com|youtube.com)\/playlist(.*)$/)) {
			const playlist = await youtube.getPlaylist(url);
			const videos = await playlist.getVideos();
			
			for (const video of Object.values(videos)) {
				const video2 = await youtube.getVideoByID(video.id);
				await handleVideo(video2, msg, voiceChannel, true);
			}
			return msg.channel.send(` **${playlist.title}** ÿ™ŸÖ ÿßŸÑÿ•ÿ∂ÿ¢ŸÅÿ© ÿ•ŸÑŸâ ŸÇÿ£ÿ¶ŸÖÿ© ÿßŸÑÿ™ÿ¥ÿ∫ŸäŸÑ`);
		} else {
			try {

				var video = await youtube.getVideo(url);
			} catch (error) {
				try {
					var videos = await youtube.searchVideos(searchString, 5);
					let index = 0;
					const embed1 = new Discord.RichEmbed()
			        .setDescription(`**ÿßŸÑÿ±ÿ¨ÿ¢ÿ° ŸÖŸÜ ÿ≠ÿ∂ÿ±ÿ™ŸÉ ÿ•ÿÆÿ™Ÿäÿ¢ÿ± ÿ±ŸÇŸÖ ÿßŸÑŸÖŸÇÿ∑ÿπ** :
${videos.map(video2 => `[**${++index} **] \`${video2.title}\``).join('\n')}`)

					.setFooter("Slash Bot")
					msg.channel.sendEmbed(embed1).then(message =>{message.delete(20000)})
					
					try {
						var response = await msg.channel.awaitMessages(msg2 => msg2.content > 0 && msg2.content < 11, {
							maxMatches: 1,
							time: 15000,
							errors: ['time']
						});
					} catch (err) {
						console.error(err);
						return msg.channel.send('ŸÑŸÖ Ÿäÿ™ŸÖ ÿ•ÿÆÿ™Ÿäÿ¢ÿ± ŸÖŸÇÿ∑ÿπ ÿµŸàÿ™Ÿä');
					}
					const videoIndex = parseInt(response.first().content);
					var video = await youtube.getVideoByID(videos[videoIndex - 1].id);
				} catch (err) {
					console.error(err);
					return msg.channel.send(':X: ŸÑÿß Ÿäÿ™ŸàŸÅÿ± ŸÜÿ™ÿ¢ÿ¶ÿ¨ ÿ®ÿ≠ÿ´ ');
				}
			}

			return handleVideo(video, msg, voiceChannel);
		}
	} else if (command === `skip`) {
		if (!msg.member.voiceChannel) return msg.channel.send('ÿ£ŸÜÿ™ ŸÑÿ≥ÿ™ ÿ®ÿ±ŸàŸÖ ÿµŸàÿ™Ÿä .');
		if (!serverQueue) return msg.channel.send('ŸÑÿß Ÿäÿ™ŸàŸÅÿ± ŸÖŸÇÿ∑ÿπ ŸÑÿ™ÿ¨ÿ¢Ÿàÿ≤Ÿá');
		serverQueue.connection.dispatcher.end('ÿ™ŸÖ ÿ™ÿ¨ÿ¢Ÿàÿ≤ Ÿáÿ∞ÿ¢ ÿßŸÑŸÖŸÇÿ∑ÿπ');
		return undefined;
	} else if (command === `stop`) {
		if (!msg.member.voiceChannel) return msg.channel.send('ÿ£ŸÜÿ™ ŸÑÿ≥ÿ™ ÿ®ÿ±ŸàŸÖ ÿµŸàÿ™Ÿä .');
		if (!serverQueue) return msg.channel.send('ŸÑÿß Ÿäÿ™ŸàŸÅÿ± ŸÖŸÇÿ∑ÿπ ŸÑÿ•ŸäŸÇÿ¢ŸÅŸá');
		serverQueue.songs = [];
		serverQueue.connection.dispatcher.end('ÿ™ŸÖ ÿ•ŸäŸÇÿ¢ŸÅ Ÿáÿ∞ÿ¢ ÿßŸÑŸÖŸÇÿ∑ÿπ');
		return undefined;
	} else if (command === `vol`) {
		if (!msg.member.voiceChannel) return msg.channel.send('ÿ£ŸÜÿ™ ŸÑÿ≥ÿ™ ÿ®ÿ±ŸàŸÖ ÿµŸàÿ™Ÿä .');
		if (!serverQueue) return msg.channel.send('ŸÑÿß ŸäŸàÿ¨ÿØ ÿ¥Ÿäÿ° ÿ¥ÿ∫ÿ¢ŸÑ.');
		if (!args[1]) return msg.channel.send(`:loud_sound: ŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑÿµŸàÿ™ **${serverQueue.volume}**`);
		serverQueue.volume = args[1];
		serverQueue.connection.dispatcher.setVolumeLogarithmic(args[1] / 50);
		return msg.channel.send(`:speaker: ÿ™ŸÖ ÿ™ÿ∫Ÿäÿ± ÿßŸÑÿµŸàÿ™ ÿßŸÑŸä **${args[1]}**`);
	} else if (command === `np`) {
		if (!serverQueue) return msg.channel.send('ŸÑÿß ŸäŸàÿ¨ÿØ ÿ¥Ÿäÿ° ÿ≠ÿßŸÑŸä ŸÅ ÿßŸÑÿπŸÖŸÑ.');
		const embedNP = new Discord.RichEmbed()
	.setDescription(`:notes: ÿßŸÑÿßŸÜ Ÿäÿ™ŸÖ ÿ™ÿ¥ÿ∫ŸäŸÑ : **${serverQueue.songs[0].title}**`)
		return msg.channel.sendEmbed(embedNP);
	} else if (command === `queue`) {
		
		if (!serverQueue) return msg.channel.send('ŸÑÿß ŸäŸàÿ¨ÿØ ÿ¥Ÿäÿ° ÿ≠ÿßŸÑŸä ŸÅ ÿßŸÑÿπŸÖŸÑ.');
		let index = 0;
		
		const embedqu = new Discord.RichEmbed()

.setDescription(`**Songs Queue**
${serverQueue.songs.map(song => `**${++index} -** ${song.title}`).join('\n')}
**ÿßŸÑÿßŸÜ Ÿäÿ™ŸÖ ÿ™ÿ¥ÿ∫ŸäŸÑ** ${serverQueue.songs[0].title}`)
		return msg.channel.sendEmbed(embedqu);
	} else if (command === `pause`) {
		if (serverQueue && serverQueue.playing) {
			serverQueue.playing = false;
			serverQueue.connection.dispatcher.pause();
			return msg.channel.send('ÿ™ŸÖ ÿ•ŸäŸÇÿßŸÅ ÿßŸÑŸÖŸàÿ≥ŸäŸÇŸâ ŸÖÿ§ŸÇÿ™ÿß!');
		}
		return msg.channel.send('ŸÑÿß ŸäŸàÿ¨ÿØ ÿ¥Ÿäÿ° ÿ≠ÿßŸÑŸä ŸÅ ÿßŸÑÿπŸÖŸÑ.');
	} else if (command === "resume") {
		if (serverQueue && !serverQueue.playing) {
			serverQueue.playing = true;
			serverQueue.connection.dispatcher.resume();
			return msg.channel.send('ÿßÿ≥ÿ™ÿ£ŸÜŸÅÿ™ ÿßŸÑŸÖŸàÿ≥ŸäŸÇŸâ ÿ®ÿßŸÑŸÜÿ≥ÿ®ÿ© ŸÑŸÉ !');
		}
		return msg.channel.send('ŸÑÿß ŸäŸàÿ¨ÿØ ÿ¥Ÿäÿ° ÿ≠ÿßŸÑŸä ŸÅŸä ÿßŸÑÿπŸÖŸÑ.');
	}

	return undefined;
});

async function handleVideo(video, msg, voiceChannel, playlist = false) {
	const serverQueue = queue.get(msg.guild.id);
	console.log(video);
	
//	console.log('yao: ' + Util.escapeMarkdown(video.thumbnailUrl));
	const song = {
		id: video.id,
		title: Util.escapeMarkdown(video.title),
		url: `https://www.youtube.com/watch?v=${video.id}`
	};
	if (!serverQueue) {
		const queueConstruct = {
			textChannel: msg.channel,
			voiceChannel: voiceChannel,
			connection: null,
			songs: [],
			volume: 5,
			playing: true
		};
		queue.set(msg.guild.id, queueConstruct);

		queueConstruct.songs.push(song);

		try {
			var connection = await voiceChannel.join();
			queueConstruct.connection = connection;
			play(msg.guild, queueConstruct.songs[0]);
		} catch (error) {
			console.error(`I could not join the voice channel: ${error}`);
			queue.delete(msg.guild.id);
			return msg.channel.send(`ŸÑÿß ÿ£ÿ≥ÿ™ÿ∑Ÿäÿπ ÿØÿÆŸàŸÑ Ÿáÿ∞ÿ¢ ÿßŸÑÿ±ŸàŸÖ ${error}`);
		}
	} else {
		serverQueue.songs.push(song);
		console.log(serverQueue.songs);
		if (playlist) return undefined;
		else return msg.channel.send(` **${song.title}** ÿ™ŸÖ ÿßÿ∂ÿßŸÅŸá ÿßŸÑÿßÿ∫ŸÜŸäÿ© ÿßŸÑŸä ÿßŸÑŸÇÿßÿ¶ŸÖÿ©!`);
	}
	return undefined;
}

function play(guild, song) {
	const serverQueue = queue.get(guild.id);

	if (!song) {
		serverQueue.voiceChannel.leave();
		queue.delete(guild.id);
		return;
	}
	console.log(serverQueue.songs);

	const dispatcher = serverQueue.connection.playStream(ytdl(song.url))
		.on('end', reason => {
			if (reason === 'Stream is not generating quickly enough.') console.log('Song ended.');
			else console.log(reason);
			serverQueue.songs.shift();
			play(guild, serverQueue.songs[0]);
		})
		.on('error', error => console.error(error));
	dispatcher.setVolumeLogarithmic(serverQueue.volume / 5);

	serverQueue.textChannel.send(`ÿ®ÿØÿ° ÿ™ÿ¥ÿ∫ŸäŸÑ : **${song.title}**`);
}





client.login(process.env.BOT_TOKEN);
